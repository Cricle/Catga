# Auto DI Registration - Zero Configuration

## ğŸ¯ Core Concept

**Just implement interfaces, framework auto-registers everything!**

- âœ… No manual `services.Add*()` calls
- âœ… Source Generator discovers implementations
- âœ… 100% compile-time, zero reflection
- âœ… Type-safe, AOT-compatible

---

## ğŸš€ Quick Start

### 1. Implement Interface

```csharp
public interface IOrderRepository
{
    Task<Order?> GetByIdAsync(string orderId);
}

// âœ… Just add attribute, that's it!
[CatgaService(Catga.ServiceLifetime.Singleton)]
public class InMemoryOrderRepository : IOrderRepository
{
    public Task<Order?> GetByIdAsync(string orderId)
    {
        // Implementation
    }
}
```

### 2. Register All Services

```csharp
// âœ… One line registers everything!
builder.Services.AddGeneratedServices();
```

### 3. Done!

**No manual registration needed!**

---

## âœ¨ Features

### Auto-Discovery

Source Generator automatically finds:
- All classes implementing public interfaces
- Marked with `[CatgaService]` attribute
- Not abstract classes

### Lifetime Control

```csharp
// Singleton (shared across app)
[CatgaService(Catga.ServiceLifetime.Singleton)]
public class CacheService : ICacheService { }

// Scoped (per request, default)
[CatgaService]  // Default is Scoped
public class OrderService : IOrderService { }

// Transient (new instance every time)
[CatgaService(Catga.ServiceLifetime.Transient)]
public class TempService : ITempService { }
```

### Opt-Out

```csharp
// Don't auto-register this service
[CatgaService(AutoRegister = false)]
public class ManualService : IManualService { }

// Register manually
services.AddScoped<IManualService>(sp =>
    new ManualService(sp.GetRequiredService<ISpecialDependency>()));
```

---

## ğŸ“Š Generated Code

Source Generator produces:

```csharp
// <auto-generated/>
namespace Catga.DependencyInjection
{
    public static class CatgaGeneratedServiceRegistrations
    {
        public static IServiceCollection AddGeneratedServices(this IServiceCollection services)
        {
            // Singleton lifetime services
            services.AddSingleton<IOrderRepository, InMemoryOrderRepository>();
            services.AddSingleton<IInventoryService, MockInventoryService>();
            services.AddSingleton<IPaymentService, MockPaymentService>();

            return services;
        }
    }
}
```

**Zero reflection, compile-time generated!**

---

## ğŸ¯ Complete Example

### Before (Traditional)

```csharp
// âŒ Manual registration for every service
builder.Services.AddSingleton<IOrderRepository, InMemoryOrderRepository>();
builder.Services.AddSingleton<IInventoryService, MockInventoryService>();
builder.Services.AddSingleton<IPaymentService, MockPaymentService>();
builder.Services.AddScoped<INotificationService, EmailNotificationService>();
builder.Services.AddScoped<IShippingService, ShippingService>();
// ... 10+ more lines
```

### After (Catga)

```csharp
// âœ… One line registers everything!
builder.Services.AddGeneratedServices();
```

**Code reduction: 100%!**

---

## ğŸ”§ Advanced Usage

### Multiple Interfaces

```csharp
// Automatically registers for all interfaces
[CatgaService(Catga.ServiceLifetime.Singleton)]
public class CombinedService : IOrderService, IInventoryService
{
    // Registered as:
    // - IOrderService â†’ CombinedService
    // - IInventoryService â†’ CombinedService
}
```

### Conditional Registration

```csharp
#if DEBUG
[CatgaService]
public class MockService : IMyService { }
#else
[CatgaService]
public class RealService : IMyService { }
#endif
```

### Mixed Registration

```csharp
// Auto-register most services
builder.Services.AddGeneratedServices();

// Manually register special cases
builder.Services.AddScoped<ISpecialService>(sp =>
    new SpecialService(sp.GetRequiredService<IComplexDependency>()));
```

---

## ğŸ“ˆ Performance

| Approach | Startup Time | Runtime Overhead | AOT Compatible |
|----------|--------------|------------------|----------------|
| **Source Generator** | ~50ms | 0 | âœ… 100% |
| Reflection Scanning | ~500ms | High | âŒ No |
| Manual Registration | ~50ms | 0 | âœ… 100% |

---

## ğŸ“ Best Practices

### 1. Use Appropriate Lifetime

```csharp
// âœ… Singleton - stateless, thread-safe
[CatgaService(Catga.ServiceLifetime.Singleton)]
public class IdGenerator : IIdGenerator { }

// âœ… Scoped - per-request state
[CatgaService]  // Default
public class OrderProcessor : IOrderProcessor { }

// âœ… Transient - independent state
[CatgaService(Catga.ServiceLifetime.Transient)]
public class TempCalculator : ICalculator { }
```

### 2. Keep Interfaces Public

```csharp
// âœ… Good - public interface
public interface IOrderService { }

// âŒ Bad - internal interface (won't be registered)
internal interface IInternalService { }
```

### 3. Avoid System Interfaces

```csharp
// âœ… Good - custom interface
public interface IOrderRepository { }

// âš ï¸ Skipped - System interface
public class MyService : IDisposable { }  // Won't register IDisposable
```

---

## ğŸ› Troubleshooting

### Q: Service not registered?

Check:
1. Class has `[CatgaService]` attribute?
2. Class implements public interface?
3. Class is not abstract?
4. Called `AddGeneratedServices()`?

### Q: How to see generated code?

```bash
# View generated registrations
cat obj/Debug/net9.0/generated/Catga.SourceGenerator/*/CatgaGeneratedServiceRegistrations.g.cs
```

### Q: Performance impact?

**Zero!** Source Generator runs at compile-time only.

---

## ğŸ‰ Summary

### Traditional Way

```csharp
// âŒ 10+ lines of manual registration
services.AddSingleton<IRepo1, Repo1>();
services.AddSingleton<IRepo2, Repo2>();
services.AddScoped<IService1, Service1>();
services.AddScoped<IService2, Service2>();
// ... more lines
```

### Catga Way

```csharp
// âœ… One line!
services.AddGeneratedServices();
```

**Users just implement interfaces, framework handles everything!**

---

<div align="center">

**ğŸš€ Zero Configuration DI - Just Implement and Go!**

[Back to Guides](../README.md) Â· [OrderSystem Example](../../examples/OrderSystem.Api/)

</div>

