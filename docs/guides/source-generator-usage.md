# Using Catga Source Generator (Zero Reflection)

## 🎯 Overview

Catga provides a **source generator** to eliminate reflection-based handler scanning, achieving:
- ✅ **Zero runtime reflection**
- ✅ **Native AOT compatibility**
- ✅ **Faster startup time**
- ✅ **Compile-time validation**

## 📦 Setup

### 1. Add Source Generator Package

```xml
<ItemGroup>
  <PackageReference Include="Catga.SourceGenerator" Version="*" PrivateAssets="all" />
</ItemGroup>
```

### 2. Define Handlers

```csharp
using Catga;
using Catga.Handlers;
using Catga.Messages;

// Auto-registered with Scoped lifetime (default)
public class CreateOrderHandler : IRequestHandler<CreateOrderRequest, CreateOrderResponse>
{
    public async ValueTask<CatgaResult<CreateOrderResponse>> HandleAsync(
        CreateOrderRequest request,
        CancellationToken cancellationToken = default)
    {
        // Handle request
        return CatgaResult<CreateOrderResponse>.Success(new CreateOrderResponse());
    }
}

// Custom lifetime
[CatgaHandler(HandlerLifetime.Singleton)]
public class CachedUserHandler : IRequestHandler<GetUserRequest, UserResponse>
{
    public async ValueTask<CatgaResult<UserResponse>> HandleAsync(
        GetUserRequest request,
        CancellationToken cancellationToken = default)
    {
        // Handle request
        return CatgaResult<UserResponse>.Success(new UserResponse());
    }
}

// Skip auto-registration
[CatgaHandler(AutoRegister = false)]
public class ManualRegistrationHandler : IRequestHandler<CustomRequest, CustomResponse>
{
    // Will NOT be auto-registered
}
```

### 3. Register Generated Handlers

```csharp
using Catga.DependencyInjection;

var builder = WebApplication.CreateBuilder(args);

// Option 1: Use source generator (recommended for AOT)
builder.Services.AddCatga()
    .AddGeneratedHandlers(); // Zero reflection!

// Option 2: Reflection-based (NOT AOT-compatible)
builder.Services.AddCatga()
    .ScanCurrentAssembly(); // Uses reflection
```

## 🎨 Handler Attribute Options

### Lifetime Control

```csharp
// Singleton - one instance for the entire application
[CatgaHandler(HandlerLifetime.Singleton)]
public class SingletonHandler : IRequestHandler<MyRequest, MyResponse> { }

// Scoped - one instance per request (default)
[CatgaHandler] // or [CatgaHandler(HandlerLifetime.Scoped)]
public class ScopedHandler : IRequestHandler<MyRequest, MyResponse> { }

// Transient - new instance every time
[CatgaHandler(HandlerLifetime.Transient)]
public class TransientHandler : IRequestHandler<MyRequest, MyResponse> { }
```

### Auto-Registration Control

```csharp
// Auto-registered (default)
public class AutoHandler : IRequestHandler<MyRequest, MyResponse> { }

// Manual registration required
[CatgaHandler(AutoRegister = false)]
public class ManualHandler : IRequestHandler<MyRequest, MyResponse> { }
```

## 🔍 Generated Code Example

The source generator produces code like this:

```csharp
// <auto-generated/>
using Microsoft.Extensions.DependencyInjection;

namespace Catga.DependencyInjection;

/// <summary>
/// Auto-generated handler registration - zero reflection, AOT-friendly
/// Found 3 handler(s)
/// </summary>
public static class CatgaGeneratedHandlerRegistrations
{
    public static IServiceCollection AddGeneratedHandlers(this IServiceCollection services)
    {
        // Singleton lifetime handlers
        services.AddSingleton<IRequestHandler<GetUserRequest, UserResponse>, CachedUserHandler>();

        // Scoped lifetime handlers
        services.AddScoped<IRequestHandler<CreateOrderRequest, CreateOrderResponse>, CreateOrderHandler>();

        // Transient lifetime handlers
        services.AddTransient<IEventHandler<OrderCreatedEvent>, OrderCreatedEventHandler>();

        return services;
    }
}
```

## 📊 Performance Comparison

| Method | Startup Time | AOT Compatible | Reflection Calls |
|--------|--------------|----------------|------------------|
| `AddGeneratedHandlers()` | ~1ms | ✅ Yes | 0 |
| `ScanCurrentAssembly()` | ~50ms | ❌ No | 100+ |

## 🚀 Best Practices

### 1. **Always use Source Generator for Production**
```csharp
// ✅ Recommended
builder.Services.AddCatga()
    .AddGeneratedHandlers();

// ❌ Avoid in production (slow, not AOT-compatible)
builder.Services.AddCatga()
    .ScanCurrentAssembly();
```

### 2. **Use Appropriate Lifetimes**
```csharp
// Stateless handlers → Singleton
[CatgaHandler(HandlerLifetime.Singleton)]
public class StatelessHandler : IRequestHandler<MyRequest, MyResponse> { }

// Handlers with dependencies → Scoped (default)
public class HandlerWithDbContext : IRequestHandler<MyRequest, MyResponse>
{
    private readonly MyDbContext _db;
    // DbContext is scoped, so handler should be too
}

// Lightweight, frequently created → Transient
[CatgaHandler(HandlerLifetime.Transient)]
public class LightweightHandler : IRequestHandler<MyRequest, MyResponse> { }
```

### 3. **Verify Generated Code**
```bash
# View generated files in obj/Debug/net9.0/generated
ls obj/Debug/net9.0/generated/Catga.SourceGenerator/
```

## 🔧 Troubleshooting

### Handlers Not Registered

**Problem**: `AddGeneratedHandlers()` doesn't register my handlers

**Solution**:
1. Ensure handlers implement `IRequestHandler<,>` or `IEventHandler<>`
2. Check handlers are `public` classes
3. Verify `Catga.SourceGenerator` package is referenced
4. Rebuild the project (`dotnet clean && dotnet build`)

### AOT Warnings

**Problem**: Still getting AOT warnings with `AddGeneratedHandlers()`

**Solution**:
- Remove any `ScanCurrentAssembly()` calls
- Check for manual reflection-based registration
- Use `TypeNameCache<T>` instead of `typeof()` in your code

## 📝 Summary

| Feature | Source Generator | Reflection |
|---------|-----------------|------------|
| Runtime Performance | ⚡⚡⚡ | ⚡ |
| AOT Compatible | ✅ | ❌ |
| Startup Time | Fast | Slow |
| Type Safety | Compile-time | Runtime |
| Code Visibility | ✅ (generated) | ❌ (black box) |

**Recommendation**: Always use `AddGeneratedHandlers()` for production deployments, especially with Native AOT.

