# Using Catga Source Generator (Zero Reflection)

## ğŸ¯ Overview

Catga provides a **source generator** to eliminate reflection-based handler scanning, achieving:
- âœ… **Zero runtime reflection**
- âœ… **Native AOT compatibility**
- âœ… **Faster startup time**
- âœ… **Compile-time validation**

## ğŸ“¦ Setup

### 1. Add Source Generator Package

```xml
<ItemGroup>
  <PackageReference Include="Catga.SourceGenerator" Version="*" PrivateAssets="all" />
</ItemGroup>
```

### 2. Define Handlers

```csharp
using Catga;
using Catga.Handlers;
using Catga.Messages;

// Auto-registered with Scoped lifetime (default)
public class CreateOrderHandler : IRequestHandler<CreateOrderRequest, CreateOrderResponse>
{
    public async ValueTask<CatgaResult<CreateOrderResponse>> HandleAsync(
        CreateOrderRequest request,
        CancellationToken cancellationToken = default)
    {
        // Handle request
        return CatgaResult<CreateOrderResponse>.Success(new CreateOrderResponse());
    }
}

// Custom lifetime
[CatgaHandler(HandlerLifetime.Singleton)]
public class CachedUserHandler : IRequestHandler<GetUserRequest, UserResponse>
{
    public async ValueTask<CatgaResult<UserResponse>> HandleAsync(
        GetUserRequest request,
        CancellationToken cancellationToken = default)
    {
        // Handle request
        return CatgaResult<UserResponse>.Success(new UserResponse());
    }
}

// Skip auto-registration
[CatgaHandler(AutoRegister = false)]
public class ManualRegistrationHandler : IRequestHandler<CustomRequest, CustomResponse>
{
    // Will NOT be auto-registered
}
```

### 3. Register Generated Handlers

```csharp
using Catga.DependencyInjection;

var builder = WebApplication.CreateBuilder(args);

// Option 1: Use source generator (recommended for AOT)
builder.Services.AddCatga()
    .AddGeneratedHandlers(); // Zero reflection!

// Option 2: Reflection-based (NOT AOT-compatible)
builder.Services.AddCatga()
    .ScanCurrentAssembly(); // Uses reflection
```

## ğŸ¨ Handler Attribute Options

### Lifetime Control

```csharp
// Singleton - one instance for the entire application
[CatgaHandler(HandlerLifetime.Singleton)]
public class SingletonHandler : IRequestHandler<MyRequest, MyResponse> { }

// Scoped - one instance per request (default)
[CatgaHandler] // or [CatgaHandler(HandlerLifetime.Scoped)]
public class ScopedHandler : IRequestHandler<MyRequest, MyResponse> { }

// Transient - new instance every time
[CatgaHandler(HandlerLifetime.Transient)]
public class TransientHandler : IRequestHandler<MyRequest, MyResponse> { }
```

### Auto-Registration Control

```csharp
// Auto-registered (default)
public class AutoHandler : IRequestHandler<MyRequest, MyResponse> { }

// Manual registration required
[CatgaHandler(AutoRegister = false)]
public class ManualHandler : IRequestHandler<MyRequest, MyResponse> { }
```

## ğŸ” Generated Code Example

The source generator produces code like this:

```csharp
// <auto-generated/>
using Microsoft.Extensions.DependencyInjection;

namespace Catga.DependencyInjection;

/// <summary>
/// Auto-generated handler registration - zero reflection, AOT-friendly
/// Found 3 handler(s)
/// </summary>
public static class CatgaGeneratedHandlerRegistrations
{
    public static IServiceCollection AddGeneratedHandlers(this IServiceCollection services)
    {
        // Singleton lifetime handlers
        services.AddSingleton<IRequestHandler<GetUserRequest, UserResponse>, CachedUserHandler>();

        // Scoped lifetime handlers
        services.AddScoped<IRequestHandler<CreateOrderRequest, CreateOrderResponse>, CreateOrderHandler>();

        // Transient lifetime handlers
        services.AddTransient<IEventHandler<OrderCreatedEvent>, OrderCreatedEventHandler>();

        return services;
    }
}
```

## ğŸ“Š Performance Comparison

| Method | Startup Time | AOT Compatible | Reflection Calls |
|--------|--------------|----------------|------------------|
| `AddGeneratedHandlers()` | ~1ms | âœ… Yes | 0 |
| `ScanCurrentAssembly()` | ~50ms | âŒ No | 100+ |

## ğŸš€ Best Practices

### 1. **Always use Source Generator for Production**
```csharp
// âœ… Recommended
builder.Services.AddCatga()
    .AddGeneratedHandlers();

// âŒ Avoid in production (slow, not AOT-compatible)
builder.Services.AddCatga()
    .ScanCurrentAssembly();
```

### 2. **Use Appropriate Lifetimes**
```csharp
// Stateless handlers â†’ Singleton
[CatgaHandler(HandlerLifetime.Singleton)]
public class StatelessHandler : IRequestHandler<MyRequest, MyResponse> { }

// Handlers with dependencies â†’ Scoped (default)
public class HandlerWithDbContext : IRequestHandler<MyRequest, MyResponse>
{
    private readonly MyDbContext _db;
    // DbContext is scoped, so handler should be too
}

// Lightweight, frequently created â†’ Transient
[CatgaHandler(HandlerLifetime.Transient)]
public class LightweightHandler : IRequestHandler<MyRequest, MyResponse> { }
```

### 3. **Verify Generated Code**
```bash
# View generated files in obj/Debug/net9.0/generated
ls obj/Debug/net9.0/generated/Catga.SourceGenerator/
```

## ğŸ§­ Endpoint Naming via Attributes

Catga supports global endpoint naming via source generator attributes. This removes repetitive per-transport configuration and keeps naming AOT-friendly.

### Assembly-level defaults (recommended)

```csharp
using Catga;
[assembly: CatgaMessageDefaults(App = "shop", BoundedContext = "orders", Separator = ".", LowerCase = true)]
```

### Per-message override (optional)

```csharp
using Catga;
[CatgaMessage(Name = "special.order.created")]
public record OrderCreatedEvent(string OrderId) : IEvent;
```

### How it works

- The generator emits a mapping `Catga.Generated.EndpointNaming` used by `AddCatga()` when `CatgaOptions.EndpointNamingConvention` is not explicitly configured.
- Transports use the following precedence:
  - NATS/Redis: `TransportOptions.Naming` > `CatgaOptions.EndpointNamingConvention` > fallback to type name
  - InMemory: uses the naming for observability tags/metrics only (does not affect routing)

### Manual configuration (explicit override)

```csharp
builder.Services.AddCatga(o =>
{
    o.EndpointNamingConvention = t => $"shop.orders.{t.Name}".ToLowerInvariant();
});
```

> Tip: Prefer attributes for zero-config projects. Use explicit configuration when you need full programmatic control.

## ğŸ”§ Troubleshooting

### Handlers Not Registered

**Problem**: `AddGeneratedHandlers()` doesn't register my handlers

**Solution**:
1. Ensure handlers implement `IRequestHandler<,>` or `IEventHandler<>`
2. Check handlers are `public` classes
3. Verify `Catga.SourceGenerator` package is referenced
4. Rebuild the project (`dotnet clean && dotnet build`)

### AOT Warnings

**Problem**: Still getting AOT warnings with `AddGeneratedHandlers()`

**Solution**:
- Remove any `ScanCurrentAssembly()` calls
- Check for manual reflection-based registration
- Use `TypeNameCache<T>` instead of `typeof()` in your code

## ğŸ“ Summary

| Feature | Source Generator | Reflection |
|---------|-----------------|------------|
| Runtime Performance | âš¡âš¡âš¡ | âš¡ |
| AOT Compatible | âœ… | âŒ |
| Startup Time | Fast | Slow |
| Type Safety | Compile-time | Runtime |
| Code Visibility | âœ… (generated) | âŒ (black box) |

**Recommendation**: Always use `AddGeneratedHandlers()` for production deployments, especially with Native AOT.

