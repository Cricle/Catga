using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator;

/// <summary>
/// Generates zero-GC IActivityTagProvider implementations for IRequest/Query types.
/// Developers annotate properties with [TraceTag] and this generator emits a partial type
/// that implements Catga.Abstractions.IActivityTagProvider to set Activity tags.
/// </summary>
[Generator]
public sealed class ActivityTagProviderGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => node is TypeDeclarationSyntax,
            static (ctx, _) => GetInfo(ctx)
        ).Where(static x => x is not null).Collect();

        context.RegisterSourceOutput(candidates, static (spc, items) =>
        {
            var list = items!.OfType<TypeInfo>().ToList();
            foreach (var info in list)
            {
                var src = GenerateSource(info);
                if (!string.IsNullOrEmpty(src))
                {
                    var hint = $"CatgaGenerated.ActivityTags.{info.HintName}.g.cs";
                    spc.AddSource(hint, SourceText.From(src!, Encoding.UTF8));
                }
            }
        });
    }

    private static TypeInfo? GetInfo(GeneratorSyntaxContext context)
    {
        if (context.Node is not TypeDeclarationSyntax typeDecl)
            return null;
        if (context.SemanticModel.GetDeclaredSymbol(typeDecl) is not INamedTypeSymbol symbol)
            return null;
        if (symbol.IsAbstract)
            return null;

        bool IsRequestInterface(INamedTypeSymbol i)
        {
            var name = i.Name;
            var ns = i.ContainingNamespace?.ToDisplayString();
            return ns == "Catga.Abstractions" && name == "IRequest" && (i.TypeArguments.Length == 0 || i.TypeArguments.Length == 1);
        }

        // Only for IRequest / IRequest<T>
        if (!symbol.AllInterfaces.Any(IsRequestInterface))
            return null;

        // Avoid generics for simplicity (can be added later)
        if (symbol.TypeParameters.Length > 0)
            return null;

        // Collect properties with [TraceTag]
        var props = new List<PropertyInfo>();
        foreach (var member in symbol.GetMembers().OfType<IPropertySymbol>())
        {
            foreach (var attr in member.GetAttributes())
            {
                if (attr.AttributeClass?.Name == "TraceTagAttribute")
                {
                    string? explicitName = null;
                    if (attr.ConstructorArguments.Length == 1 && attr.ConstructorArguments[0].Value is string s && !string.IsNullOrWhiteSpace(s))
                        explicitName = s;

                    props.Add(new PropertyInfo(member.Name, member.Type, explicitName));
                    break;
                }
            }
        }

        if (props.Count == 0)
            return null;

        var nsName = symbol.ContainingNamespace?.ToDisplayString() ?? "";
        var isStruct = symbol.IsValueType;
        var typeName = symbol.Name; // no generics supported here
        var hintName = (string.IsNullOrEmpty(nsName) ? typeName : nsName + "." + typeName).Replace('<', '_').Replace('>', '_');
        return new TypeInfo(nsName, typeName, isStruct, hintName, props);
    }

    private static string GenerateSource(TypeInfo info)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        if (!string.IsNullOrEmpty(info.Namespace))
        {
            sb.Append("namespace ").Append(info.Namespace).AppendLine(";");
            sb.AppendLine();
        }

        var typeKeyword = info.IsStruct ? "struct" : "class";
        sb.Append("partial ").Append(typeKeyword).Append(' ').Append(info.TypeName)
          .Append(" : global::Catga.Abstractions.IActivityTagProvider")
          .AppendLine()
          .AppendLine("{")
          .AppendLine("    void global::Catga.Abstractions.IActivityTagProvider.Enrich(global::System.Diagnostics.Activity activity)")
          .AppendLine("    {");

        foreach (var p in info.Properties)
        {
            var tagName = !string.IsNullOrEmpty(p.ExplicitName) ? p.ExplicitName : $"catga.req.{p.Name}";
            // Generate minimally allocating SetTag
            sb.Append("        activity?.SetTag(\"").Append(Escape(tagName)).Append("\", ");
            // Use typed literal for common primitives to avoid boxing where possible is not necessary since Activity.SetTag accepts object?;
            sb.Append("this.").Append(p.Name).AppendLine(");");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string Escape(string s) => s.Replace("\\", "\\\\").Replace("\"", "\\\"");

    private sealed record TypeInfo(string Namespace, string TypeName, bool IsStruct, string HintName, List<PropertyInfo> Properties)
    {
        public string Namespace { get; } = Namespace;
        public string TypeName { get; } = TypeName;
        public bool IsStruct { get; } = IsStruct;
        public string HintName { get; } = HintName;
        public List<PropertyInfo> Properties { get; } = Properties;
    }

    private sealed record PropertyInfo(string Name, ITypeSymbol Type, string? ExplicitName)
    {
        public string Name { get; } = Name;
        public ITypeSymbol Type { get; } = Type;
        public string? ExplicitName { get; } = ExplicitName;
    }
}
