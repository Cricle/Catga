using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator;

/// <summary>
/// Base class for Catga source generators
/// Provides common utilities and patterns
/// </summary>
public abstract class BaseSourceGenerator
{
    /// <summary>
    /// Generator name for diagnostics
    /// </summary>
    protected abstract string GeneratorName { get; }

    /// <summary>
    /// Add source with UTF-8 encoding
    /// </summary>
    protected static void AddSource(SourceProductionContext context, string hintName, string source)
    {
        context.AddSource(hintName, SourceText.From(source, Encoding.UTF8));
    }

    /// <summary>
    /// Generate file header comment
    /// </summary>
    protected string GenerateFileHeader()
    {
        return $@"// <auto-generated/>
// Generated by {GeneratorName}
// DO NOT EDIT - This file is auto-generated and will be overwritten

#nullable enable
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member

";
    }

    /// <summary>
    /// Generate namespace wrapper
    /// </summary>
    protected static string WrapInNamespace(string namespaceName, string content)
    {
        return $@"namespace {namespaceName}
{{
{content}
}}";
    }

    /// <summary>
    /// Generate using statements
    /// </summary>
    protected static string GenerateUsings(params string[] namespaces)
    {
        var sb = new StringBuilder();
        foreach (var ns in namespaces)
        {
            sb.AppendLine($"using {ns};");
        }
        return sb.ToString();
    }

    /// <summary>
    /// Indent code block
    /// </summary>
    protected static string Indent(string code, int level = 1)
    {
        var indent = new string(' ', level * 4);
        var lines = code.Split(new[] { '\n' }, System.StringSplitOptions.None);
        return string.Join("\n", lines.Select(line => 
            string.IsNullOrWhiteSpace(line) ? line : indent + line));
    }

    /// <summary>
    /// Check if symbol is accessible (public or internal)
    /// </summary>
    protected static bool IsAccessible(ISymbol symbol)
    {
        return symbol.DeclaredAccessibility is Accessibility.Public or Accessibility.Internal;
    }

    /// <summary>
    /// Get full type name with namespace
    /// </summary>
    protected static string GetFullTypeName(ITypeSymbol typeSymbol)
    {
        return typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
            .Replace("global::", "");
    }
}

