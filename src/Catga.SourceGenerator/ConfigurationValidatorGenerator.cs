using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator;

/// <summary>
/// Generates validation code for configuration classes
/// Validates:
/// - Range constraints (min/max)
/// - Required properties
/// - Format validation
/// </summary>
[Generator]
public class ConfigurationValidatorGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register marker interface
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("IValidatableConfiguration.g.cs", SourceText.From(InterfaceSource, Encoding.UTF8));
        });

        // Find all classes implementing IValidatableConfiguration
        var configProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsConfigurationCandidate(node),
                transform: static (ctx, _) => GetConfigurationInfo(ctx))
            .Where(static m => m is not null)
            .Collect();

        // Generate validation code
        context.RegisterSourceOutput(configProvider, static (spc, configs) =>
        {
            foreach (var config in configs)
            {
                if (config == null) continue;
                
                var source = GenerateValidationCode(config);
                spc.AddSource($"{config.TypeName}.Validation.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        });
    }

    private static bool IsConfigurationCandidate(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax classDecl)
            return false;

        if (classDecl.BaseList == null)
            return false;

        // Check if implements IValidatableConfiguration
        return classDecl.BaseList.Types
            .Any(t => t.Type.ToString().Contains("IValidatableConfiguration"));
    }

    private static ConfigurationInfo? GetConfigurationInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl);

        if (symbol is not INamedTypeSymbol typeSymbol)
            return null;

        // Get all properties
        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public && p.SetMethod != null)
            .Select(p => AnalyzeProperty(p))
            .ToImmutableArray();

        return new ConfigurationInfo
        {
            TypeName = typeSymbol.Name,
            Namespace = typeSymbol.ContainingNamespace.ToDisplayString(),
            Properties = properties,
            IsPartial = classDecl.Modifiers.Any(m => m.Text == "partial")
        };
    }

    private static PropertyValidationInfo AnalyzeProperty(IPropertySymbol property)
    {
        var info = new PropertyValidationInfo
        {
            Name = property.Name,
            Type = property.Type.ToDisplayString(),
            IsNullable = property.NullableAnnotation == NullableAnnotation.Annotated
        };

        // Analyze type for validation rules
        var typeName = property.Type.ToDisplayString();
        
        // Numeric types - check for positive values
        if (typeName is "int" or "long" or "double" or "float" or "decimal")
        {
            info.ShouldBePositive = property.Name.Contains("Max") || 
                                   property.Name.Contains("Count") || 
                                   property.Name.Contains("Size") ||
                                   property.Name.Contains("Capacity") ||
                                   property.Name.Contains("Limit");
        }

        // TimeSpan - check for positive duration
        if (typeName == "System.TimeSpan")
        {
            info.ShouldBePositive = property.Name.Contains("Timeout") || 
                                   property.Name.Contains("Duration") ||
                                   property.Name.Contains("Interval");
        }

        // String - check for required
        if (typeName == "string" && !info.IsNullable)
        {
            info.IsRequired = property.Name.Contains("Url") || 
                             property.Name.Contains("Connection") ||
                             property.Name.Contains("Path");
        }

        return info;
    }

    private static string GenerateValidationCode(ConfigurationInfo config)
    {
        if (!config.IsPartial)
        {
            return $@"// <auto-generated/>
// Warning: {config.TypeName} must be declared as 'partial' to implement IValidatableConfiguration
";
        }

        var sb = new StringBuilder();
        
        // Header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine($"// Generated by ConfigurationValidatorGenerator for {config.TypeName}");
        sb.AppendLine("// DO NOT EDIT");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS1591");
        sb.AppendLine();

        // Usings
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {config.Namespace}");
        sb.AppendLine("{");

        // Partial class
        sb.AppendLine($"    partial class {config.TypeName}");
        sb.AppendLine("    {");

        // Generate Validate method
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Validates the configuration");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public IEnumerable<string> Validate()");
        sb.AppendLine("        {");

        foreach (var prop in config.Properties)
        {
            // Required string validation
            if (prop.Type == "string" && prop.IsRequired && !prop.IsNullable)
            {
                sb.AppendLine($"            if (string.IsNullOrWhiteSpace({prop.Name}))");
                sb.AppendLine($"                yield return \"{prop.Name} is required and cannot be empty\";");
                sb.AppendLine();
            }

            // Positive number validation
            if (prop.ShouldBePositive)
            {
                if (prop.Type == "System.TimeSpan")
                {
                    sb.AppendLine($"            if ({prop.Name} <= TimeSpan.Zero)");
                    sb.AppendLine($"                yield return \"{prop.Name} must be positive\";");
                    sb.AppendLine();
                }
                else if (prop.Type is "int" or "long" or "double" or "float" or "decimal")
                {
                    sb.AppendLine($"            if ({prop.Name} <= 0)");
                    sb.AppendLine($"                yield return \"{prop.Name} must be positive\";");
                    sb.AppendLine();
                }
            }
        }

        sb.AppendLine("        }");
        sb.AppendLine();

        // Generate ValidateAndThrow method
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Validates the configuration and throws if invalid");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public void ValidateAndThrow()");
        sb.AppendLine("        {");
        sb.AppendLine("            var errors = Validate().ToList();");
        sb.AppendLine("            if (errors.Count > 0)");
        sb.AppendLine("            {");
        sb.AppendLine($"                throw new InvalidOperationException(");
        sb.AppendLine($"                    $\"{config.TypeName} validation failed: {{string.Join(\", \", errors)}}\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private const string InterfaceSource = @"// <auto-generated/>
#nullable enable

namespace Catga.Configuration
{
    /// <summary>
    /// Marker interface for configuration classes that support validation
    /// Implementing this interface will trigger code generation for validation logic
    /// </summary>
    public interface IValidatableConfiguration
    {
        /// <summary>
        /// Validates the configuration and returns validation errors
        /// </summary>
        System.Collections.Generic.IEnumerable<string> Validate();

        /// <summary>
        /// Validates the configuration and throws if invalid
        /// </summary>
        void ValidateAndThrow();
    }
}";

    private sealed class ConfigurationInfo
    {
        public string TypeName { get; set; } = null!;
        public string Namespace { get; set; } = null!;
        public ImmutableArray<PropertyValidationInfo> Properties { get; set; }
        public bool IsPartial { get; set; }
    }

    private sealed class PropertyValidationInfo
    {
        public string Name { get; set; } = null!;
        public string Type { get; set; } = null!;
        public bool IsNullable { get; set; }
        public bool IsRequired { get; set; }
        public bool ShouldBePositive { get; set; }
    }
}

