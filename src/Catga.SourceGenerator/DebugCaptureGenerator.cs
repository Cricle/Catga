using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator;

/// <summary>
/// Generates IDebugCapture implementations for messages marked with [GenerateDebugCapture]
/// </summary>
[Generator]
public class DebugCaptureGenerator : IIncrementalGenerator
{
    private const string AttributeSource = @"// <auto-generated/>
#nullable enable

namespace Catga.Debugger.Core;

/// <summary>
/// Generates IDebugCapture implementation for AOT-compatible variable capture
/// </summary>
[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, AllowMultiple = false)]
[System.Diagnostics.Conditional(""CODE_GENERATION"")]
public sealed class GenerateDebugCaptureAttribute : System.Attribute
{
    /// <summary>Include private properties</summary>
    public bool IncludePrivate { get; set; }

    /// <summary>Max collection count to capture (prevents large data dumps)</summary>
    public int MaxCollectionCount { get; set; } = 10;

    /// <summary>Properties to exclude (comma-separated)</summary>
    public string? Exclude { get; set; }
}
";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register attribute source
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("GenerateDebugCaptureAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Find all types with [GenerateDebugCapture] attribute
        var typeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsCandidateNode(node),
                transform: static (ctx, _) => GetSemanticTarget(ctx))
            .Where(static m => m is not null);

        // Combine with compilation
        var compilationAndTypes = context.CompilationProvider.Combine(typeDeclarations.Collect());

        // Generate source
        context.RegisterSourceOutput(compilationAndTypes, static (spc, source) => Execute(source.Left, source.Right!, spc));
    }

    private static bool IsCandidateNode(SyntaxNode node)
    {
        return node is TypeDeclarationSyntax typeDecl && typeDecl.AttributeLists.Count > 0;
    }

    private static TypeDeclarationSyntax? GetSemanticTarget(GeneratorSyntaxContext context)
    {
        var typeDecl = (TypeDeclarationSyntax)context.Node;

        foreach (var attributeList in typeDecl.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var symbolInfo = context.SemanticModel.GetSymbolInfo(attribute);
                if (symbolInfo.Symbol is not IMethodSymbol attributeSymbol)
                    continue;

                var attributeName = attributeSymbol.ContainingType.ToDisplayString();
                if (attributeName == "Catga.Debugger.Core.GenerateDebugCaptureAttribute")
                {
                    return typeDecl;
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<TypeDeclarationSyntax?> types, SourceProductionContext context)
    {
        if (types.IsDefaultOrEmpty)
            return;

        var distinctTypes = types.Where(t => t is not null).Distinct();

        foreach (var typeDecl in distinctTypes)
        {
            if (typeDecl is null)
                continue;

            context.CancellationToken.ThrowIfCancellationRequested();

            var semanticModel = compilation.GetSemanticModel(typeDecl.SyntaxTree);
            var typeSymbol = semanticModel.GetDeclaredSymbol(typeDecl) as INamedTypeSymbol;

            if (typeSymbol is null)
                continue;

            var source = GenerateDebugCaptureImplementation(typeSymbol, typeDecl, context);
            if (source != null)
            {
                var fileName = $"{typeSymbol.Name}_DebugCapture.g.cs";
                context.AddSource(fileName, SourceText.From(source, Encoding.UTF8));
            }
        }
    }

    private static string? GenerateDebugCaptureImplementation(INamedTypeSymbol typeSymbol, TypeDeclarationSyntax typeDecl, SourceProductionContext context)
    {
        // Get attribute arguments
        var includePrivate = false;
        var maxCollectionCount = 10;
        var excludeProperties = new HashSet<string>();

        var attribute = typeSymbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "Catga.Debugger.Core.GenerateDebugCaptureAttribute");

        if (attribute is not null)
        {
            foreach (var namedArg in attribute.NamedArguments)
            {
                switch (namedArg.Key)
                {
                    case "IncludePrivate":
                        includePrivate = (bool?)namedArg.Value.Value ?? false;
                        break;
                    case "MaxCollectionCount":
                        maxCollectionCount = (int?)namedArg.Value.Value ?? 10;
                        break;
                    case "Exclude":
                        var excludeStr = (string?)namedArg.Value.Value;
                        if (!string.IsNullOrWhiteSpace(excludeStr))
                        {
                            foreach (var prop in excludeStr!.Split(','))
                            {
                                excludeProperties.Add(prop.Trim());
                            }
                        }
                        break;
                }
            }
        }

        // Get all properties
        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => !p.IsStatic && p.DeclaredAccessibility == Accessibility.Public || (includePrivate && p.DeclaredAccessibility == Accessibility.Private))
            .Where(p => !excludeProperties.Contains(p.Name))
            .ToList();

        if (properties.Count == 0)
            return null;

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Namespace
        var namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();
        if (!string.IsNullOrEmpty(namespaceName))
        {
            sb.AppendLine($"namespace {namespaceName};");
            sb.AppendLine();
        }

        // Type declaration
        var keyword = typeDecl.Keyword.Text; // class, struct, record
        var typeParams = typeSymbol.IsGenericType
            ? $"<{string.Join(", ", typeSymbol.TypeParameters.Select(tp => tp.Name))}>"
            : "";

        sb.AppendLine($"partial {keyword} {typeSymbol.Name}{typeParams} : Catga.Debugger.Core.IDebugCapture");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>Capture variables for debugging (auto-generated, AOT-compatible)</summary>");
        sb.AppendLine("    public System.Collections.Generic.Dictionary<string, object?> CaptureVariables()");
        sb.AppendLine("    {");
        sb.AppendLine("        return new System.Collections.Generic.Dictionary<string, object?>");
        sb.AppendLine("        {");

        foreach (var property in properties)
        {
            var propertyName = property.Name;
            var propertyType = property.Type;

            // Check if it's a collection
            var isCollection = IsCollectionType(propertyType);

            if (isCollection)
            {
                // For collections, capture count instead of full data
                sb.AppendLine($"            [\"{propertyName}\"] = {propertyName}?.Count ?? 0,");
            }
            else if (propertyType.SpecialType == SpecialType.System_String || propertyType.IsValueType)
            {
                // Simple types: capture directly
                sb.AppendLine($"            [\"{propertyName}\"] = {propertyName},");
            }
            else
            {
                // Complex types: capture ToString() or type name
                sb.AppendLine($"            [\"{propertyName}\"] = {propertyName}?.ToString() ?? \"null\",");
            }
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static bool IsCollectionType(ITypeSymbol type)
    {
        // Check if implements IEnumerable (but not string)
        if (type.SpecialType == SpecialType.System_String)
            return false;

        return type.AllInterfaces.Any(i =>
            i.ToDisplayString().StartsWith("System.Collections.Generic.IEnumerable") ||
            i.ToDisplayString().StartsWith("System.Collections.Generic.ICollection") ||
            i.ToDisplayString().StartsWith("System.Collections.Generic.IList"));
    }
}

