// <auto-generated>
// Catga Source Generator: EndpointNamingGenerator
// Generates a static mapping from message types to endpoint names, based on
// assembly-level defaults and optional per-message overrides.
// Keeps code minimal and AOT-friendly.
// </auto-generated>

#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator
{
    [Generator]
    public sealed class EndpointNamingGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Emit attributes so users can decorate assembly or message types
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource("CatgaMessageDefaultsAttribute.g.cs", SourceText.From(DefaultsAttributeSource, Encoding.UTF8));
                ctx.AddSource("CatgaMessageAttribute.g.cs", SourceText.From(MessageAttributeSource, Encoding.UTF8));
            });

            // Collect message type declarations
            var messages = context.SyntaxProvider
                .CreateSyntaxProvider(static (node, _) => IsCandidate(node), static (ctx, _) => GetMessageType(ctx))
                .Where(static m => m is not null);

            // Combine with compilation to read assembly-level defaults
            var combined = context.CompilationProvider.Combine(messages.Collect());

            context.RegisterSourceOutput(combined, static (spc, pair) =>
            {
                var (compilation, messageItems) = pair;
                var defaults = ReadAssemblyDefaults(compilation.Assembly);
                var messageList = messageItems.Where(i => i is not null).Select(i => i!).ToList();
                var source = GenerateEndpointNaming(messageList, defaults);
                spc.AddSource("CatgaGenerated.EndpointNaming.g.cs", SourceText.From(source, Encoding.UTF8));
                spc.AddSource("CatgaGenerated.EndpointNamingExtensions.g.cs", SourceText.From(GenerateEndpointNamingExtensions(), Encoding.UTF8));
                spc.AddSource("CatgaGenerated.Bootstrap.EndpointNaming.Init.g.cs", SourceText.From(GenerateBootstrap(), Encoding.UTF8));
            });
        }

        private static bool IsCandidate(SyntaxNode node)
        {
            // record/class/struct with interfaces
            if (node is not TypeDeclarationSyntax t) return false;
            if (t.BaseList is null || t.BaseList.Types.Count == 0) return false;
            // not nested types (keep generator simple)
            if (t.Parent is TypeDeclarationSyntax) return false;
            return true;
        }

        private static MessageItem? GetMessageType(GeneratorSyntaxContext context)
        {
            var t = (TypeDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(t) as INamedTypeSymbol;
            if (symbol is null) return null;

            // Must implement IRequest/ IEvent/ IMessage (by simple name match to avoid hard refs)
            var implementsMessage = symbol.AllInterfaces.Any(i =>
                i.Name is "IRequest" or "IEvent" or "IMessage" ||
                i.Name.StartsWith("IRequest") || i.Name.StartsWith("IEvent"));
            if (!implementsMessage) return null;

            // Optional per-message override attribute
            string? overrideName = null;
            var msgAttr = symbol.GetAttributes().FirstOrDefault(a => a.AttributeClass?.Name == "CatgaMessageAttribute");
            if (msgAttr != null)
            {
                foreach (var kv in msgAttr.NamedArguments)
                {
                    if (kv.Key == "Name" && kv.Value.Value is string s && !string.IsNullOrWhiteSpace(s))
                        overrideName = s;
                }
            }

            return new MessageItem(
                FullName(symbol),
                symbol.Name,
                overrideName
            );
        }

        private static Defaults ReadAssemblyDefaults(IAssemblySymbol assembly)
        {
            var def = new Defaults("", "", ".", false, null);
            foreach (var attr in assembly.GetAttributes())
            {
                if (attr.AttributeClass?.Name == "CatgaMessageDefaultsAttribute")
                {
                    foreach (var arg in attr.NamedArguments)
                    {
                        switch (arg.Key)
                        {
                            case "App": def.App = arg.Value.Value as string ?? def.App; break;
                            case "BoundedContext": def.BoundedContext = arg.Value.Value as string ?? def.BoundedContext; break;
                            case "Separator": def.Separator = arg.Value.Value as string ?? def.Separator; break;
                            case "LowerCase": def.LowerCase = arg.Value.Value is bool b && b; break;
                            case "Prefix": def.Prefix = arg.Value.Value as string; break;
                        }
                    }
                }
            }
            return def;
        }

        private static string GenerateEndpointNaming(IReadOnlyList<MessageItem> messages, Defaults defaults)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();
            sb.AppendLine("namespace Catga.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    internal static class EndpointNaming");
            sb.AppendLine("    {");
            sb.AppendLine("        private static readonly Dictionary<string,string> _map = new()");
            sb.AppendLine("        {");

            for (int i = 0; i < messages.Count; i++)
            {
                var m = messages[i];
                var name = ComputeName(m, defaults);
                sb.AppendLine($"            [\"{Escape(m.FullName)}\"] = \"{Escape(name)}\",");
            }

            sb.AppendLine("        };");
            sb.AppendLine();
            sb.AppendLine("        public static bool TryGet(Type t, out string name) => _map.TryGetValue(t.FullName!, out name!);");
            sb.AppendLine("        public static Func<Type,string> GetConvention() => (t) => _map.TryGetValue(t.FullName!, out var n) ? n : t.Name; ");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static string GenerateBootstrap()
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using System.Runtime.CompilerServices;");
            sb.AppendLine();
            sb.AppendLine("namespace Catga.Generated");
            sb.AppendLine("{");
            sb.AppendLine("    internal static class EndpointNamingBootstrapInit");
            sb.AppendLine("    {");
            sb.AppendLine("        [ModuleInitializer]");
            sb.AppendLine("        internal static void Initialize()");
            sb.AppendLine("        {");
            sb.AppendLine("            global::Catga.Generated.GeneratedBootstrapRegistry.RegisterEndpointConvention(global::Catga.Generated.EndpointNaming.GetConvention());");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static string GenerateEndpointNamingExtensions()
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using Catga.DependencyInjection;");
            sb.AppendLine();
            sb.AppendLine("namespace Catga.DependencyInjection");
            sb.AppendLine("{");
            sb.AppendLine("    /// <summary>");
            sb.AppendLine("    /// Reflection-free extension to apply generated endpoint naming");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    public static class CatgaGeneratedEndpointNamingExtensions");
            sb.AppendLine("    {");
            sb.AppendLine("        public static CatgaServiceBuilder UseGeneratedEndpointNaming(this CatgaServiceBuilder builder)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (builder is null) return null!;");
            sb.AppendLine("            builder.Options.EndpointNamingConvention = Catga.Generated.EndpointNaming.GetConvention();");
            sb.AppendLine("            return builder;");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static string ComputeName(MessageItem m, Defaults d)
        {
            var msgName = m.OverrideName ?? m.SimpleName;
            var parts = new List<string>();
            if (!string.IsNullOrWhiteSpace(d.Prefix)) parts.Add(d.Prefix!.Trim('.'));
            if (!string.IsNullOrWhiteSpace(d.App)) parts.Add(d.App);
            if (!string.IsNullOrWhiteSpace(d.BoundedContext)) parts.Add(d.BoundedContext);
            parts.Add(msgName);
            var sep = string.IsNullOrEmpty(d.Separator) ? "." : d.Separator;
            var s = string.Join(sep, parts);
            return d.LowerCase ? s.ToLowerInvariant() : s;
        }

        private static string FullName(INamedTypeSymbol s)
        {
            var ns = s.ContainingNamespace?.ToDisplayString();
            return string.IsNullOrEmpty(ns) ? s.Name : ns + "." + s.Name;
        }

        private static string Escape(string s) => s.Replace("\\", "\\\\").Replace("\"", "\\\"");

        private sealed class MessageItem
        {
            public string FullName { get; }
            public string SimpleName { get; }
            public string? OverrideName { get; }
            public MessageItem(string fullName, string simpleName, string? overrideName)
            {
                FullName = fullName;
                SimpleName = simpleName;
                OverrideName = overrideName;
            }
        }

        private sealed class Defaults
        {
            public string App { get; set; }
            public string BoundedContext { get; set; }
            public string Separator { get; set; }
            public bool LowerCase { get; set; }
            public string? Prefix { get; set; }
            public Defaults(string app, string boundedContext, string separator, bool lowerCase, string? prefix)
            {
                App = app;
                BoundedContext = boundedContext;
                Separator = separator;
                LowerCase = lowerCase;
                Prefix = prefix;
            }
        }

        private const string DefaultsAttributeSource = @"// <auto-generated/>
#nullable enable
namespace Catga;

/// <summary>
/// Assembly-level defaults for message endpoint naming.
/// Example:
/// [assembly: CatgaMessageDefaults(App = ""shop"", BoundedContext = ""orders"", Separator = ""."", LowerCase = true)]
/// </summary>
[System.AttributeUsage(System.AttributeTargets.Assembly, AllowMultiple = false)]
public sealed class CatgaMessageDefaultsAttribute : System.Attribute
{
    public string? App { get; set; }
    public string? BoundedContext { get; set; }
    public string Separator { get; set; } = ""."";
    public bool LowerCase { get; set; } = true;
    public string? Prefix { get; set; }
}
";

        private const string MessageAttributeSource = @"// <auto-generated/>
#nullable enable
namespace Catga;

/// <summary>
/// Optional per-message naming override.
/// </summary>
[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct | System.AttributeTargets.Interface | System.AttributeTargets.Assembly, AllowMultiple = true)]
public sealed class CatgaMessageAttribute : System.Attribute
{
    public string? Name { get; set; }
}
";
    }
}
