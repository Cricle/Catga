// <auto-generated>
// Source Generator that emits a zero-reflection event router
// </auto-generated>

#nullable enable

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator
{
	[Generator]
	public sealed class EventRouterGenerator : IIncrementalGenerator
	{
		public void Initialize(IncrementalGeneratorInitializationContext context)
		{
			// Discover classes implementing Catga.Handlers.IEventHandler<TEvent>
			var handlers = context.SyntaxProvider
				.CreateSyntaxProvider(static (node, _) => node is ClassDeclarationSyntax c && c.BaseList is not null,
					static (ctx, _) => GetHandler(ctx))
				.Where(static h => h is not null)
				.Collect();

			context.RegisterSourceOutput(handlers, static (spc, items) =>
			{
				var list = items.Where(i => i is not null)!.ToList();
				spc.AddSource("CatgaGeneratedEventRouter.g.cs", SourceText.From(GenerateRouter(list), Encoding.UTF8));
			});
		}

		private static HandlerItem? GetHandler(GeneratorSyntaxContext context)
		{
			var classDecl = (ClassDeclarationSyntax)context.Node;
			var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
			if (symbol is null) return null;

			foreach (var itf in symbol.AllInterfaces)
			{
				var name = itf.OriginalDefinition.ToDisplayString();
				if (name == "Catga.Handlers.IEventHandler<TEvent>")
				{
					var eventType = itf.TypeArguments[0].ToDisplayString();
					return new HandlerItem(symbol.ToDisplayString(), eventType);
				}
			}
			return null;
		}

		private static string GenerateRouter(IReadOnlyList<HandlerItem?> handlers)
		{
			var sb = new StringBuilder();
			sb.AppendLine("// <auto-generated/>");
			sb.AppendLine("#nullable enable");
			sb.AppendLine("using System;");
			sb.AppendLine("using System.Threading;");
			sb.AppendLine("using System.Threading.Tasks;");
			sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
			sb.AppendLine("using Catga.Core;using Catga.Abstractions;");
			sb.AppendLine("using Catga.Core;");
			sb.AppendLine();
			sb.AppendLine("namespace Catga.Generated");
			sb.AppendLine("{");
			sb.AppendLine("    internal sealed class GeneratedEventRouter : IGeneratedEventRouter");
			sb.AppendLine("    {");
			sb.AppendLine("        public bool TryRoute<TEvent>(IServiceProvider sp, TEvent @event, CancellationToken ct, out Task? dispatched) where TEvent : IEvent");
			sb.AppendLine("        {");
			sb.AppendLine("            dispatched = null;");
			if (handlers.Count == 0)
			{
				sb.AppendLine("            return false;");
			}
			else
			{
				// Generate type tests and dispatch without reflection
				var index = 0;
				foreach (var h in handlers)
				{
					if (h is null) continue;
					var varName = $"ev{index++}";
					sb.AppendLine($"            if (@event is {h.EventType} {varName})");
					sb.AppendLine("            {");
					sb.AppendLine($"                var handlers = sp.GetServices<Catga.Handlers.IEventHandler<{h.EventType}>>();");
					sb.AppendLine("                var tasks = new System.Collections.Generic.List<Task>();");
					sb.AppendLine("                foreach (var handler in handlers)");
					sb.AppendLine($"                    tasks.Add(handler.HandleAsync({varName}, ct));");
					sb.AppendLine("                dispatched = Task.WhenAll(tasks);");
					sb.AppendLine("                return true;");
					sb.AppendLine("            }");
				}
				sb.AppendLine("            return false;");
			}
			sb.AppendLine("        }");
			sb.AppendLine("    }");
			sb.AppendLine("}");
			return sb.ToString();
		}

		private sealed class HandlerItem
		{
			public string HandlerType { get; }
			public string EventType { get; }
			public HandlerItem(string handlerType, string eventType)
			{
				HandlerType = handlerType;
				EventType = eventType;
			}
		}
	}
}
