using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator;

/// <summary>
/// Generates ExecuteFlowAsync() for partial classes with [FlowStep] methods.
/// User defines steps with parameters, generator creates the flow execution method.
/// </summary>
[Generator]
public class FlowGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register FlowStep attribute
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("FlowStepAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Find all methods with [FlowStep] attribute
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsFlowStepCandidate(node),
                transform: static (ctx, _) => GetStepInfo(ctx))
            .Where(static m => m is not null)
            .Collect();

        context.RegisterSourceOutput(provider, static (spc, steps) =>
        {
            var byClass = steps.Where(s => s != null).GroupBy(s => s!.FullClassName).ToList();
            foreach (var group in byClass)
            {
                var info = group.First()!;
                var orderedSteps = group.OrderBy(s => s!.Order).ToList()!;
                var source = GenerateFlowMethod(info.Namespace, info.ClassName, orderedSteps);
                spc.AddSource($"{info.ClassName}.Flow.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        });
    }

    private static bool IsFlowStepCandidate(SyntaxNode node)
    {
        if (node is not MethodDeclarationSyntax method) return false;
        // Check if method has any attribute containing "FlowStep"
        return method.AttributeLists.Any(al =>
            al.Attributes.Any(a => a.Name.ToString().Contains("FlowStep")));
    }

    private static StepInfo? GetStepInfo(GeneratorSyntaxContext ctx)
    {
        var methodSyntax = (MethodDeclarationSyntax)ctx.Node;
        var method = ctx.SemanticModel.GetDeclaredSymbol(methodSyntax) as IMethodSymbol;
        if (method == null) return null;

        var type = method.ContainingType;
        if (type == null) return null;

        // Find FlowStep attribute
        var attr = method.GetAttributes().FirstOrDefault(a =>
            a.AttributeClass?.Name == "FlowStepAttribute");
        if (attr == null) return null;

        int order = 0;
        string? compensate = null;
        foreach (var arg in attr.NamedArguments)
        {
            if (arg.Key == "Order") order = (int)(arg.Value.Value ?? 0);
            if (arg.Key == "Compensate") compensate = arg.Value.Value as string;
        }

        // Get method parameters
        var parameters = method.Parameters.Select(p => new ParamInfo
        {
            Name = p.Name,
            Type = p.Type.ToDisplayString()
        }).ToList();

        return new StepInfo
        {
            Namespace = type.ContainingNamespace.ToDisplayString(),
            ClassName = type.Name,
            FullClassName = type.ToDisplayString(),
            MethodName = method.Name,
            Order = order,
            Compensate = compensate,
            Parameters = parameters,
            IsAsync = method.IsAsync || method.ReturnType.ToDisplayString().StartsWith("System.Threading.Tasks")
        };
    }

    private static string GenerateFlowMethod(string ns, string className, List<StepInfo?> steps)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Catga.Flow;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(ns) && ns != "<global namespace>")
        {
            sb.AppendLine($"namespace {ns};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial class {className}");
        sb.AppendLine("{");

        // Collect all unique parameters from all steps
        var allParams = new Dictionary<string, string>();
        foreach (var step in steps)
        {
            if (step == null) continue;
            foreach (var p in step.Parameters)
            {
                if (!allParams.ContainsKey(p.Name))
                    allParams[p.Name] = p.Type;
            }
        }

        // Generate ExecuteFlowAsync with all parameters
        var paramList = allParams.Count > 0
            ? string.Join(", ", allParams.Select(p => $"{p.Value} {p.Key}")) + ", "
            : "";

        sb.AppendLine("    /// <summary>Execute flow with automatic compensation on failure.</summary>");
        sb.AppendLine($"    public async Task<FlowResult> ExecuteFlowAsync({paramList}CancellationToken ct = default)");
        sb.AppendLine("    {");
        sb.AppendLine($"        return await Flow.Create(\"{className}\")");

        foreach (var step in steps)
        {
            if (step == null) continue;
            var args = string.Join(", ", step.Parameters.Select(p => p.Name));
            var hasCompensate = !string.IsNullOrEmpty(step.Compensate);

            if (hasCompensate)
                sb.AppendLine($"            .Step(async () => await {step.MethodName}({args}), async () => await {step.Compensate}({args}))");
            else
                sb.AppendLine($"            .Step(async () => await {step.MethodName}({args}))");
        }

        sb.AppendLine("            .ExecuteAsync(ct);");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private const string AttributeSource = @"// <auto-generated/>
#nullable enable

namespace Catga.Flow;

/// <summary>
/// Marks a method as a flow step. Source Generator creates ExecuteFlowAsync() automatically.
/// </summary>
/// <example>
/// public partial class OrderService
/// {
///     [FlowStep(Order = 1)]
///     private async Task SaveOrder(Order order) => await _repo.SaveAsync(order);
///
///     [FlowStep(Order = 2, Compensate = nameof(ReleaseStock))]
///     private async Task ReserveStock(Order order) => await _inventory.ReserveAsync(order);
///
///     private async Task ReleaseStock(Order order) => await _inventory.ReleaseAsync(order);
/// }
/// // Generated: public async Task&lt;FlowResult&gt; ExecuteFlowAsync(Order order, CancellationToken ct)
/// </example>
[System.AttributeUsage(System.AttributeTargets.Method, AllowMultiple = false)]
public sealed class FlowStepAttribute : System.Attribute
{
    /// <summary>Step execution order (required).</summary>
    public int Order { get; set; }

    /// <summary>Compensation method name (optional). Called on failure in reverse order.</summary>
    public string? Compensate { get; set; }
}
";

    private class StepInfo
    {
        public string Namespace { get; set; } = "";
        public string ClassName { get; set; } = "";
        public string FullClassName { get; set; } = "";
        public string MethodName { get; set; } = "";
        public int Order { get; set; }
        public string? Compensate { get; set; }
        public List<ParamInfo> Parameters { get; set; } = new();
        public bool IsAsync { get; set; }
    }

    private class ParamInfo
    {
        public string Name { get; set; } = "";
        public string Type { get; set; } = "";
    }
}
