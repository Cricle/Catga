using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator;

/// <summary>
/// Generates IFlowState implementation with change tracking for classes marked with [FlowState].
/// </summary>
[Generator]
public class FlowStateGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Note: FlowStateAttribute is defined in Catga.Flow.Dsl namespace (Catga library)
        // No need to generate it here

        // Find all classes with [FlowState] attribute
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsFlowStateCandidate(node),
                transform: static (ctx, _) => GetFlowStateInfo(ctx))
            .Where(static m => m is not null);

        context.RegisterSourceOutput(provider, static (spc, info) =>
        {
            if (info == null) return;
            var source = GenerateFlowState(info);
            spc.AddSource($"{info.ClassName}.FlowState.g.cs", SourceText.From(source, Encoding.UTF8));
        });
    }

    private static bool IsFlowStateCandidate(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax classDecl) return false;
        // Check if class has partial modifier and any attribute containing "FlowState"
        if (!classDecl.Modifiers.Any(m => m.ValueText == "partial")) return false;
        return classDecl.AttributeLists.Any(al =>
            al.Attributes.Any(a => a.Name.ToString().Contains("FlowState")));
    }

    private static FlowStateInfo? GetFlowStateInfo(GeneratorSyntaxContext ctx)
    {
        var classSyntax = (ClassDeclarationSyntax)ctx.Node;
        var symbol = ctx.SemanticModel.GetDeclaredSymbol(classSyntax) as INamedTypeSymbol;
        if (symbol == null) return null;

        // Find FlowState attribute
        var attr = symbol.GetAttributes().FirstOrDefault(a =>
            a.AttributeClass?.Name == "FlowStateAttribute");
        if (attr == null) return null;

        // Get all properties that should be tracked
        var properties = new List<PropertyInfo>();
        foreach (var member in symbol.GetMembers())
        {
            if (member is not IPropertySymbol prop) continue;
            if (prop.IsStatic) continue;
            if (prop.Name == "FlowId") continue; // Skip FlowId, it's handled separately
            if (prop.SetMethod == null) continue; // Must have setter

            // Check for [FlowStateIgnore] attribute
            if (prop.GetAttributes().Any(a => a.AttributeClass?.Name == "FlowStateIgnoreAttribute"))
                continue;

            // Check if property has auto-implemented getter/setter (no body)
            var propSyntax = prop.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax() as PropertyDeclarationSyntax;
            var isAutoProperty = propSyntax?.AccessorList?.Accessors.All(a => a.Body == null && a.ExpressionBody == null) ?? false;

            properties.Add(new PropertyInfo
            {
                Name = prop.Name,
                Type = prop.Type.ToDisplayString(),
                IsNullable = prop.Type.NullableAnnotation == NullableAnnotation.Annotated ||
                            prop.Type.IsReferenceType,
                IsAutoProperty = isAutoProperty
            });
        }

        return new FlowStateInfo
        {
            Namespace = symbol.ContainingNamespace.ToDisplayString(),
            ClassName = symbol.Name,
            Properties = properties
        };
    }

    private static string GenerateFlowState(FlowStateInfo info)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using Catga.Flow.Dsl;");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(info.Namespace) && info.Namespace != "<global namespace>")
        {
            sb.AppendLine($"namespace {info.Namespace};");
            sb.AppendLine();
        }

        sb.AppendLine($"partial class {info.ClassName} : IFlowState");
        sb.AppendLine("{");

        // Field constants
        for (int i = 0; i < info.Properties.Count; i++)
        {
            sb.AppendLine($"    public const int Field_{info.Properties[i].Name} = {i};");
        }
        sb.AppendLine($"    public const int FieldCount = {info.Properties.Count};");
        sb.AppendLine();

        // Change tracking field
        sb.AppendLine("    private int _flowState_changedMask;");
        sb.AppendLine();

        // FlowId property
        sb.AppendLine("    public string? FlowId { get; set; }");
        sb.AppendLine();

        // Generate Set methods with auto change tracking for each property
        for (int i = 0; i < info.Properties.Count; i++)
        {
            var prop = info.Properties[i];
            sb.AppendLine($"    /// <summary>Set {prop.Name} with automatic change tracking.</summary>");
            sb.AppendLine($"    public void Set{prop.Name}({prop.Type} value)");
            sb.AppendLine("    {");
            sb.AppendLine($"        if (!EqualityComparer<{prop.Type}>.Default.Equals({prop.Name}, value))");
            sb.AppendLine("        {");
            sb.AppendLine($"            {prop.Name} = value;");
            sb.AppendLine($"            _flowState_changedMask |= (1 << {i});");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        // IFlowState implementation
        sb.AppendLine("    public bool HasChanges => _flowState_changedMask != 0;");
        sb.AppendLine();
        sb.AppendLine("    public int GetChangedMask() => _flowState_changedMask;");
        sb.AppendLine();
        sb.AppendLine("    public bool IsFieldChanged(int fieldIndex) => (_flowState_changedMask & (1 << fieldIndex)) != 0;");
        sb.AppendLine();
        sb.AppendLine("    public void ClearChanges() => _flowState_changedMask = 0;");
        sb.AppendLine();
        sb.AppendLine("    public void MarkChanged(int fieldIndex) => _flowState_changedMask |= (1 << fieldIndex);");
        sb.AppendLine();

        // GetChangedFieldNames
        sb.AppendLine("    public IEnumerable<string> GetChangedFieldNames()");
        sb.AppendLine("    {");
        foreach (var prop in info.Properties)
        {
            sb.AppendLine($"        if (IsFieldChanged(Field_{prop.Name})) yield return \"{prop.Name}\";");
        }
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }

    // Note: FlowStateAttribute and FlowStateIgnoreAttribute are defined in
    // Catga.Flow.Dsl namespace (src/Catga/Flow/Abstractions.cs)

    private class FlowStateInfo
    {
        public string Namespace { get; set; } = "";
        public string ClassName { get; set; } = "";
        public List<PropertyInfo> Properties { get; set; } = new();
    }

    private class PropertyInfo
    {
        public string Name { get; set; } = "";
        public string Type { get; set; } = "";
        public bool IsNullable { get; set; }
        public bool IsAutoProperty { get; set; }
    }
}
