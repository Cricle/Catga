#nullable enable
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator;

/// <summary>
/// Incremental source generator that discovers all IRequestHandler and IEventHandler
/// implementations and generates a static handler cache for zero-allocation dispatch.
/// <para>
/// Generated files:
/// - CatgaGeneratedHandlerCache.g.cs: Static cache with type mappings
/// - CatgaGenerated.Bootstrap.Handlers.Init.g.cs: Module initializer for auto-registration
/// </para>
/// </summary>
[Generator]
public sealed class HandlerCacheGenerator : IIncrementalGenerator
{
    private const string RequestHandlerInterface = "Catga.Abstractions.IRequestHandler<TRequest, TResponse>";
    private const string EventHandlerInterface = "Catga.Abstractions.IEventHandler<TEvent>";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var handlers = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is ClassDeclarationSyntax { BaseList: not null },
                transform: static (ctx, _) => ExtractHandlerInfo(ctx))
            .Where(static h => h is not null)
            .Collect();

        context.RegisterSourceOutput(handlers, static (spc, items) =>
        {
            var handlerList = items.Where(i => i is not null).ToList();
            spc.AddSource("CatgaGeneratedHandlerCache.g.cs",
                SourceText.From(GenerateHandlerCache(handlerList!), Encoding.UTF8));
            spc.AddSource("CatgaGenerated.Bootstrap.Handlers.Init.g.cs",
                SourceText.From(GenerateBootstrap(), Encoding.UTF8));
        });
    }

    #region Handler Discovery

    private static HandlerInfo? ExtractHandlerInfo(GeneratorSyntaxContext context)
    {
        if (context.SemanticModel.GetDeclaredSymbol((ClassDeclarationSyntax)context.Node) is not INamedTypeSymbol { IsAbstract: false } symbol)
            return null;

        foreach (var iface in symbol.AllInterfaces)
        {
            var ifaceName = iface.OriginalDefinition.ToDisplayString();

            if (ifaceName == RequestHandlerInterface && iface.TypeArguments.Length == 2)
            {
                return new HandlerInfo(
                    HandlerKind.Request,
                    iface.TypeArguments[0].ToDisplayString(),
                    iface.TypeArguments[1].ToDisplayString(),
                    symbol.ToDisplayString());
            }

            if (ifaceName == EventHandlerInterface && iface.TypeArguments.Length == 1)
            {
                return new HandlerInfo(
                    HandlerKind.Event,
                    iface.TypeArguments[0].ToDisplayString(),
                    null,
                    symbol.ToDisplayString());
            }
        }

        return null;
    }

    #endregion

    #region Code Generation

    private static string GenerateHandlerCache(IReadOnlyList<HandlerInfo> handlers)
    {
        var requestHandlers = handlers.Where(h => h.Kind == HandlerKind.Request).ToList();
        var eventHandlers = handlers.Where(h => h.Kind == HandlerKind.Event).ToList();
        var eventGroups = eventHandlers.GroupBy(h => h.RequestType).ToList();

        var sb = new StringBuilder();
        sb.AppendLine("""
            // <auto-generated/>
            #nullable enable
            using System;
            using System.Collections.Concurrent;
            using System.Collections.Generic;
            using System.Runtime.CompilerServices;
            using Microsoft.Extensions.DependencyInjection;
            using Microsoft.Extensions.DependencyInjection.Extensions;

            namespace Catga.Generated;

            /// <summary>
            /// Auto-generated handler cache for zero-allocation dispatch.
            /// </summary>
            internal static class GeneratedHandlerCache
            {
                private static readonly ConcurrentDictionary<Type, object?> _cache = new();

            """);

        // Request handler type mapping
        sb.AppendLine("    private static readonly Dictionary<Type, Type> _requestHandlers = new()");
        sb.AppendLine("    {");
        foreach (var h in requestHandlers)
            sb.AppendLine($"        [typeof({h.RequestType})] = typeof({h.HandlerType}),");
        sb.AppendLine("    };");
        sb.AppendLine();

        // Event handler type mapping
        sb.AppendLine("    private static readonly Dictionary<Type, Type[]> _eventHandlers = new()");
        sb.AppendLine("    {");
        foreach (var g in eventGroups)
        {
            var types = string.Join(", ", g.Select(h => $"typeof({h.HandlerType})"));
            sb.AppendLine($"        [typeof({g.Key})] = new[] {{ {types} }},");
        }
        sb.AppendLine("    };");
        sb.AppendLine();

        // Methods
        sb.AppendLine("""
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static THandler? GetHandler<TRequest, THandler>(IServiceProvider sp) where THandler : class
                {
                    var key = typeof(TRequest);
                    if (_cache.TryGetValue(key, out var cached))
                        return cached as THandler;

                    if (!_requestHandlers.TryGetValue(key, out var handlerType))
                        return null;

                    var handler = sp.GetService(handlerType) as THandler;
                    _cache.TryAdd(key, handler);
                    return handler;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static bool HasHandler<TRequest>() => _requestHandlers.ContainsKey(typeof(TRequest));

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                public static Type[]? GetEventHandlers<TEvent>()
                    => _eventHandlers.TryGetValue(typeof(TEvent), out var types) ? types : null;

                public static void Register(IServiceCollection services)
                {
            """);

        // Use TryAddSingleton for handlers (ICatgaMediator is now Singleton)
        var distinctHandlers = new HashSet<string>();
        foreach (var h in handlers.Where(x => distinctHandlers.Add(x.HandlerType)))
            sb.AppendLine($"        services.TryAddSingleton<{h.HandlerType}>();");

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateBootstrap() => """
        // <auto-generated/>
        #nullable enable
        using System.Runtime.CompilerServices;

        namespace Catga.Generated;

        internal static class HandlersBootstrapInit
        {
            [ModuleInitializer]
            internal static void Initialize()
                => GeneratedBootstrapRegistry.Register(GeneratedHandlerCache.Register);
        }
        """;

    #endregion

    #region Types

    private enum HandlerKind { Request, Event }

    private sealed class HandlerInfo
    {
        public HandlerKind Kind { get; }
        public string RequestType { get; }
        public string? ResponseType { get; }
        public string HandlerType { get; }

        public HandlerInfo(HandlerKind kind, string requestType, string? responseType, string handlerType)
        {
            Kind = kind;
            RequestType = requestType;
            ResponseType = responseType;
            HandlerType = handlerType;
        }
    }

    #endregion
}
