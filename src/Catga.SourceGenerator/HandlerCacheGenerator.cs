#nullable enable
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator;

/// <summary>
/// Auto-discovers IRequestHandler and IEventHandler implementations
/// and generates static handler cache for zero-allocation dispatch.
/// </summary>
[Generator]
public sealed class HandlerCacheGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Discover all handler implementations
        var handlers = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax c && c.BaseList is not null,
                static (ctx, _) => GetHandlerInfo(ctx))
            .Where(static h => h is not null)
            .Collect();

        context.RegisterSourceOutput(handlers, static (spc, items) =>
        {
            var list = items.Where(i => i is not null).ToList();
            spc.AddSource("CatgaGeneratedHandlerCache.g.cs",
                SourceText.From(GenerateHandlerCache(list!), Encoding.UTF8));
            spc.AddSource("CatgaGenerated.Bootstrap.Handlers.Init.g.cs",
                SourceText.From(GenerateBootstrap(), Encoding.UTF8));
        });
    }

    private static HandlerInfo? GetHandlerInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
        if (symbol is null || symbol.IsAbstract) return null;

        // Find IRequestHandler<TRequest, TResponse> or IEventHandler<TEvent> interfaces
        foreach (var iface in symbol.AllInterfaces)
        {
            var ifaceName = iface.OriginalDefinition.ToDisplayString();

            // IRequestHandler<TRequest, TResponse>
            if (ifaceName == "Catga.Abstractions.IRequestHandler<TRequest, TResponse>" && iface.TypeArguments.Length == 2)
            {
                var requestType = iface.TypeArguments[0].ToDisplayString();
                var responseType = iface.TypeArguments[1].ToDisplayString();
                var handlerType = symbol.ToDisplayString();

                return new HandlerInfo(
                    HandlerKind.Request,
                    requestType,
                    responseType,
                    handlerType
                );
            }

            // IEventHandler<TEvent>
            if (ifaceName == "Catga.Abstractions.IEventHandler<TEvent>" && iface.TypeArguments.Length == 1)
            {
                var eventType = iface.TypeArguments[0].ToDisplayString();
                var handlerType = symbol.ToDisplayString();

                return new HandlerInfo(
                    HandlerKind.Event,
                    eventType,
                    null,
                    handlerType
                );
            }
        }

        return null;
    }

    private static string GenerateHandlerCache(IReadOnlyList<HandlerInfo> handlers)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Concurrent;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection.Extensions;");
        sb.AppendLine();
        sb.AppendLine("namespace Catga.Generated;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Auto-generated handler cache for zero-allocation dispatch.");
        sb.AppendLine($"/// Found {handlers.Count} handler(s).");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("internal static class GeneratedHandlerCache");
        sb.AppendLine("{");

        // Generate static cache
        sb.AppendLine("    // Static handler instance cache (populated on first access)");
        sb.AppendLine("    private static readonly ConcurrentDictionary<Type, object?> _handlerCache = new();");
        sb.AppendLine();

        // Generate request handler type mapping
        var requestHandlers = handlers.Where(h => h.Kind == HandlerKind.Request).ToList();
        sb.AppendLine("    // Request type -> Handler type mapping (compile-time known)");
        sb.AppendLine("    private static readonly Dictionary<Type, Type> _requestHandlerTypes = new()");
        sb.AppendLine("    {");
        foreach (var h in requestHandlers)
        {
            sb.AppendLine($"        [typeof({h.RequestType})] = typeof({h.HandlerType}),");
        }
        sb.AppendLine("    };");
        sb.AppendLine();

        // Generate event handler type mapping
        var eventHandlers = handlers.Where(h => h.Kind == HandlerKind.Event).ToList();
        sb.AppendLine("    // Event type -> Handler types mapping (compile-time known)");
        sb.AppendLine("    private static readonly Dictionary<Type, Type[]> _eventHandlerTypes = new()");
        sb.AppendLine("    {");
        var eventGroups = eventHandlers.GroupBy(h => h.RequestType);
        foreach (var g in eventGroups)
        {
            var types = string.Join(", ", g.Select(h => $"typeof({h.HandlerType})"));
            sb.AppendLine($"        [typeof({g.Key})] = new Type[] {{ {types} }},");
        }
        sb.AppendLine("    };");
        sb.AppendLine();

        // Generate GetRequestHandler method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Get cached request handler instance. Returns null if not found.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public static THandler? GetRequestHandler<TRequest, TResponse, THandler>(IServiceProvider sp)");
        sb.AppendLine("        where THandler : class");
        sb.AppendLine("    {");
        sb.AppendLine("        var requestType = typeof(TRequest);");
        sb.AppendLine("        if (_handlerCache.TryGetValue(requestType, out var cached))");
        sb.AppendLine("            return cached as THandler;");
        sb.AppendLine();
        sb.AppendLine("        // First access: resolve and cache");
        sb.AppendLine("        if (!_requestHandlerTypes.TryGetValue(requestType, out var handlerType))");
        sb.AppendLine("            return null;");
        sb.AppendLine();
        sb.AppendLine("        var handler = sp.GetService(handlerType) as THandler;");
        sb.AppendLine("        _handlerCache.TryAdd(requestType, handler);");
        sb.AppendLine("        return handler;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate HasHandler method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Check if a handler exists for the request type (compile-time known).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public static bool HasRequestHandler<TRequest>()");
        sb.AppendLine("        => _requestHandlerTypes.ContainsKey(typeof(TRequest));");
        sb.AppendLine();

        // Generate GetEventHandlerTypes method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Get event handler types for the event type (compile-time known).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public static Type[]? GetEventHandlerTypes<TEvent>()");
        sb.AppendLine("        => _eventHandlerTypes.TryGetValue(typeof(TEvent), out var types) ? types : null;");
        sb.AppendLine();

        // Generate RegisterHandlers method for DI
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Register all discovered handlers as Singleton.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static void RegisterHandlers(IServiceCollection services)");
        sb.AppendLine("    {");
        var distinctHandlers = new HashSet<string>();
        foreach (var h in handlers.Where(x => distinctHandlers.Add(x.HandlerType)))
        {
            sb.AppendLine($"        services.TryAddSingleton<{h.HandlerType}>();");
        }
        sb.AppendLine("    }");

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateBootstrap()
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine();
        sb.AppendLine("namespace Catga.Generated;");
        sb.AppendLine();
        sb.AppendLine("internal static class HandlersBootstrapInit");
        sb.AppendLine("{");
        sb.AppendLine("    [ModuleInitializer]");
        sb.AppendLine("    internal static void Initialize()");
        sb.AppendLine("    {");
        sb.AppendLine("        global::Catga.Generated.GeneratedBootstrapRegistry.Register(static services => global::Catga.Generated.GeneratedHandlerCache.RegisterHandlers(services));");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private enum HandlerKind
    {
        Request,
        Event
    }

    private sealed class HandlerInfo
    {
        public HandlerKind Kind { get; }
        public string RequestType { get; }
        public string? ResponseType { get; }
        public string HandlerType { get; }

        public HandlerInfo(HandlerKind kind, string requestType, string? responseType, string handlerType)
        {
            Kind = kind;
            RequestType = requestType;
            ResponseType = responseType;
            HandlerType = handlerType;
        }
    }
}
