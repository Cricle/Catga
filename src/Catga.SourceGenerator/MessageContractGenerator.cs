using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator;

/// <summary>
/// Generates boilerplate code for message contracts (Commands, Queries, Events)
/// - Validation logic
/// - JSON serialization context (AOT-friendly)
/// - MemoryPack support
/// - ToString() implementation
/// </summary>
[Generator]
public class MessageContractGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register marker attribute
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("GenerateMessageContractAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Find all classes marked with [GenerateMessageContract]
        var messageProvider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => IsMessageCandidate(node),
                transform: static (ctx, _) => GetMessageInfo(ctx))
            .Where(static m => m is not null)
            .Collect();

        // Generate code for each message
        context.RegisterSourceOutput(messageProvider, static (spc, messages) =>
        {
            foreach (var message in messages)
            {
                if (message == null) continue;
                
                var source = GenerateMessageContract(message);
                spc.AddSource($"{message.TypeName}.g.cs", SourceText.From(source, Encoding.UTF8));
            }
        });
    }

    private static bool IsMessageCandidate(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax and not RecordDeclarationSyntax)
            return false;

        var typeDecl = (TypeDeclarationSyntax)node;
        
        // Check for [GenerateMessageContract] attribute
        return typeDecl.AttributeLists
            .SelectMany(al => al.Attributes)
            .Any(a => a.Name.ToString().Contains("GenerateMessageContract"));
    }

    private static MessageInfo? GetMessageInfo(GeneratorSyntaxContext context)
    {
        var typeDecl = (TypeDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(typeDecl);

        if (symbol is not INamedTypeSymbol typeSymbol)
            return null;

        // Get all properties
        var properties = typeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => p.DeclaredAccessibility == Accessibility.Public)
            .Select(p => new PropertyInfo
            {
                Name = p.Name,
                Type = p.Type.ToDisplayString(),
                IsRequired = p.IsRequired,
                IsNullable = p.NullableAnnotation == NullableAnnotation.Annotated
            })
            .ToImmutableArray();

        // Check if it's a request, event, etc.
        var isRequest = typeSymbol.AllInterfaces.Any(i => 
            i.ToDisplayString().StartsWith("Catga.Messages.IRequest<"));
        var isEvent = typeSymbol.AllInterfaces.Any(i => 
            i.ToDisplayString() == "Catga.Messages.IEvent");

        return new MessageInfo
        {
            TypeName = typeSymbol.Name,
            FullTypeName = typeSymbol.ToDisplayString(),
            Namespace = typeSymbol.ContainingNamespace.ToDisplayString(),
            Properties = properties,
            IsRequest = isRequest,
            IsEvent = isEvent,
            IsPartial = typeDecl.Modifiers.Any(m => m.Text == "partial")
        };
    }

    private static string GenerateMessageContract(MessageInfo message)
    {
        if (!message.IsPartial)
        {
            // If not partial, just return a comment
            return $@"// <auto-generated/>
// Warning: {message.TypeName} must be declared as 'partial' to use [GenerateMessageContract]
";
        }

        var sb = new StringBuilder();
        
        // Header
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine($"// Generated by MessageContractGenerator for {message.TypeName}");
        sb.AppendLine("// DO NOT EDIT");
        sb.AppendLine();
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS1591");
        sb.AppendLine();

        // Usings
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Text.Json.Serialization;");
        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {message.Namespace}");
        sb.AppendLine("{");

        // Partial class
        sb.AppendLine($"    partial class {message.TypeName}");
        sb.AppendLine("    {");

        // Generate Validate method
        sb.AppendLine(GenerateValidateMethod(message));
        sb.AppendLine();

        // Generate ToString method
        sb.AppendLine(GenerateToStringMethod(message));
        sb.AppendLine();

        // Generate GetHashCode method
        sb.AppendLine(GenerateGetHashCodeMethod(message));

        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate JSON serialization context (AOT-friendly)
        sb.AppendLine(GenerateJsonContext(message));

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GenerateValidateMethod(MessageInfo message)
    {
        var sb = new StringBuilder();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Validates the message properties");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public IEnumerable<string> Validate()");
        sb.AppendLine("        {");

        foreach (var prop in message.Properties)
        {
            // Required string validation
            if (prop.Type == "string" && prop.IsRequired && !prop.IsNullable)
            {
                sb.AppendLine($"            if (string.IsNullOrWhiteSpace({prop.Name}))");
                sb.AppendLine($"                yield return \"{prop.Name} is required\";");
                sb.AppendLine();
            }
            // Required non-nullable reference type
            else if (!prop.Type.Contains("?") && !prop.IsNullable && prop.IsRequired)
            {
                sb.AppendLine($"            if ({prop.Name} == null)");
                sb.AppendLine($"                yield return \"{prop.Name} is required\";");
                sb.AppendLine();
            }
        }

        sb.AppendLine("        }");
        return sb.ToString();
    }

    private static string GenerateToStringMethod(MessageInfo message)
    {
        var sb = new StringBuilder();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Returns a string representation of the message");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public override string ToString()");
        sb.AppendLine("        {");
        
        if (message.Properties.Length == 0)
        {
            sb.AppendLine($"            return \"{message.TypeName} {{ }}\";");
        }
        else
        {
            sb.Append($"            return $\"{message.TypeName} {{ ");
            
            var propStrings = message.Properties
                .Select(p => $"{p.Name} = {{{p.Name}}}");
            sb.Append(string.Join(", ", propStrings));
            
            sb.AppendLine(" }\";");
        }
        
        sb.AppendLine("        }");
        return sb.ToString();
    }

    private static string GenerateGetHashCodeMethod(MessageInfo message)
    {
        var sb = new StringBuilder();
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Returns a hash code for the message");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public override int GetHashCode()");
        sb.AppendLine("        {");
        
        if (message.Properties.Length == 0)
        {
            sb.AppendLine("            return 0;");
        }
        else if (message.Properties.Length == 1)
        {
            sb.AppendLine($"            return {message.Properties[0].Name}?.GetHashCode() ?? 0;");
        }
        else
        {
            sb.AppendLine("            var hash = new HashCode();");
            foreach (var prop in message.Properties)
            {
                sb.AppendLine($"            hash.Add({prop.Name});");
            }
            sb.AppendLine("            return hash.ToHashCode();");
        }
        
        sb.AppendLine("        }");
        return sb.ToString();
    }

    private static string GenerateJsonContext(MessageInfo message)
    {
        var sb = new StringBuilder();
        sb.AppendLine("    /// <summary>");
        sb.AppendLine($"    /// JSON serialization context for {message.TypeName} (AOT-friendly)");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    [JsonSerializable(typeof({message.TypeName}))]");
        sb.AppendLine($"    internal partial class {message.TypeName}JsonContext : JsonSerializerContext");
        sb.AppendLine("    {");
        sb.AppendLine("    }");
        return sb.ToString();
    }

    private const string AttributeSource = @"// <auto-generated/>
#nullable enable

namespace Catga.SourceGenerator
{
    /// <summary>
    /// Marks a message type for code generation
    /// Generates: Validation, ToString, GetHashCode, JSON context
    /// </summary>
    [System.AttributeUsage(System.AttributeTargets.Class, AllowMultiple = false)]
    public sealed class GenerateMessageContractAttribute : System.Attribute
    {
    }
}";

    private sealed class MessageInfo
    {
        public string TypeName { get; set; } = null!;
        public string FullTypeName { get; set; } = null!;
        public string Namespace { get; set; } = null!;
        public ImmutableArray<PropertyInfo> Properties { get; set; }
        public bool IsRequest { get; set; }
        public bool IsEvent { get; set; }
        public bool IsPartial { get; set; }
    }

    private sealed class PropertyInfo
    {
        public string Name { get; set; } = null!;
        public string Type { get; set; } = null!;
        public bool IsRequired { get; set; }
        public bool IsNullable { get; set; }
    }
}

