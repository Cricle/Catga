using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Catga.SourceGenerator;

/// <summary>
/// Source Generator that automatically adds MessageId property with default value
/// for record/class/struct types implementing IRequest, IEvent, or IMessage
/// </summary>
[Generator]
public class MessageIdGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register a syntax provider to find message type declarations (record, class, struct)
        var messageTypeDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsMessageType(s),
                transform: static (ctx, _) => GetTypeInfo(ctx))
            .Where(static m => m is not null);

        // Generate code for each message type
        context.RegisterSourceOutput(messageTypeDeclarations,
            static (spc, typeInfo) => Execute(typeInfo!, spc));
    }

    private static bool IsMessageType(SyntaxNode node)
    {
        // Check if it's a record, class, or struct declaration
        TypeDeclarationSyntax? typeDeclaration = node switch
        {
            RecordDeclarationSyntax record => record,
            ClassDeclarationSyntax @class => @class,
            StructDeclarationSyntax @struct => @struct,
            _ => null
        };

        if (typeDeclaration == null)
            return false;

        // Must have a base list (implements interfaces)
        if (typeDeclaration.BaseList == null || !typeDeclaration.BaseList.Types.Any())
            return false;

        // Must be partial
        if (!typeDeclaration.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)))
            return false;

        // Must not be nested (Source Generator limitation for simplicity)
        if (typeDeclaration.Parent is TypeDeclarationSyntax)
            return false;

        // Check if it implements IRequest, IEvent, or IMessage
        var baseTypes = typeDeclaration.BaseList.Types
            .Select(t => t.Type.ToString())
            .ToList();

        return baseTypes.Any(bt =>
            bt.Contains("IRequest") ||
            bt.Contains("IEvent") ||
            bt.Contains("IReliableEvent") ||
            bt.Contains("IMessage"));
    }

    private static TypeInfo? GetTypeInfo(GeneratorSyntaxContext context)
    {
        var typeDeclaration = (TypeDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get semantic information
        var typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration);
        if (typeSymbol == null)
            return null;

        // Check if MessageId property already exists
        var hasMessageIdProperty = typeSymbol.GetMembers("MessageId")
            .Any(m => m is IPropertySymbol || m is IFieldSymbol);

        if (hasMessageIdProperty)
            return null;

        // For records with primary constructor, check parameters
        if (typeDeclaration is RecordDeclarationSyntax recordDeclaration)
        {
            var hasMessageIdParameter = recordDeclaration.ParameterList?.Parameters
                .Any(p => p.Identifier.Text == "MessageId") ?? false;

            if (hasMessageIdParameter)
                return null;
        }

        // Get namespace
        var namespaceDeclaration = typeDeclaration.Ancestors()
            .OfType<BaseNamespaceDeclarationSyntax>()
            .FirstOrDefault();

        var namespaceName = namespaceDeclaration?.Name.ToString() ?? "Global";
        var typeName = typeDeclaration.Identifier.Text;

        // Determine type kind
        var typeKind = typeDeclaration switch
        {
            RecordDeclarationSyntax => "record",
            ClassDeclarationSyntax => "class",
            StructDeclarationSyntax => "struct",
            _ => "class"
        };

        return new TypeInfo
        {
            Namespace = namespaceName,
            TypeName = typeName,
            TypeKind = typeKind
        };
    }

    private static void Execute(TypeInfo typeInfo, SourceProductionContext context)
    {
        var source = GeneratePartialType(typeInfo);
        context.AddSource($"{typeInfo.TypeName}.MessageId.g.cs",
            SourceText.From(source, Encoding.UTF8));
    }

    private static string GeneratePartialType(TypeInfo typeInfo)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Catga.Core;");
        sb.AppendLine();
        sb.AppendLine($"namespace {typeInfo.Namespace};");
        sb.AppendLine();
        sb.AppendLine($"partial {typeInfo.TypeKind} {typeInfo.TypeName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Unique message identifier. Auto-generated using SnowflakeIdGenerator.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public long MessageId { get; init; } = MessageExtensions.NewMessageId();");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private class TypeInfo
    {
        public string Namespace { get; set; } = string.Empty;
        public string TypeName { get; set; } = string.Empty;
        public string TypeKind { get; set; } = string.Empty; // "record", "class", or "struct"
    }
}

