using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Catga.SourceGenerator;

/// <summary>
/// Auto-discovers and registers service implementations
/// Users just implement interfaces, framework auto-registers them
/// </summary>
[Generator]
public sealed class ServiceRegistrationGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register attribute for service lifetime control
        context.RegisterPostInitializationOutput(ctx =>
        {
            ctx.AddSource("CatgaServiceAttribute.g.cs", SourceText.From(AttributeSource, Encoding.UTF8));
        });

        // Discover all service implementations
        var services = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is ClassDeclarationSyntax c && c.BaseList is not null,
                static (ctx, _) => GetServiceInfo(ctx))
            .Where(static s => s is not null)
            .Collect();

        context.RegisterSourceOutput(services, static (spc, items) =>
        {
            var list = items.Where(i => i is not null).ToList();
            spc.AddSource("CatgaGeneratedServiceRegistrations.g.cs",
                SourceText.From(GenerateRegistrations(list!), Encoding.UTF8));
        });
    }

    private static ServiceInfo? GetServiceInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl) as INamedTypeSymbol;
        if (symbol is null || symbol.IsAbstract) return null;

        // Check for [CatgaService] attribute
        var attribute = symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "CatgaServiceAttribute");

        if (attribute == null) return null;

        var lifetime = "Scoped";
        var autoRegister = true;
        string? serviceType = null;
        string? implType = null;

        // Read Lifetime
        var lifetimeArg = attribute.NamedArguments
            .FirstOrDefault(kvp => kvp.Key == "Lifetime");
        if (lifetimeArg.Value.Value is int lifetimeValue)
        {
            lifetime = lifetimeValue switch
            {
                0 => "Singleton",
                1 => "Scoped",
                2 => "Transient",
                _ => "Scoped"
            };
        }

        // Read ServiceType (interface)
        var serviceTypeArg = attribute.NamedArguments
            .FirstOrDefault(kvp => kvp.Key == "ServiceType");
        if (serviceTypeArg.Value.Value is INamedTypeSymbol serviceTypeSymbol)
        {
            serviceType = serviceTypeSymbol.ToDisplayString();
        }

        // Read ImplType (implementation)
        var implTypeArg = attribute.NamedArguments
            .FirstOrDefault(kvp => kvp.Key == "ImplType");
        if (implTypeArg.Value.Value is INamedTypeSymbol implTypeSymbol)
        {
            implType = implTypeSymbol.ToDisplayString();
        }

        // Read AutoRegister
        var autoRegisterArg = attribute.NamedArguments
            .FirstOrDefault(kvp => kvp.Key == "AutoRegister");
        if (autoRegisterArg.Value.Value is bool autoRegValue)
        {
            autoRegister = autoRegValue;
        }

        if (!autoRegister) return null;

        // Determine implementation type (defaults to marked class)
        var implementationType = implType ?? symbol.ToDisplayString();

        // Determine service types to register
        List<string> interfacesToRegister = new();

        if (serviceType != null)
        {
            // ServiceType specified: Register as ServiceType -> ImplType
            interfacesToRegister.Add(serviceType);
        }
        // If ServiceType not specified: Only register concrete type (no interface)

        return new ServiceInfo(
            implementationType,
            interfacesToRegister,
            lifetime
        );
    }

    private static string GenerateRegistrations(IReadOnlyList<ServiceInfo> services)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("namespace Catga.DependencyInjection");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Auto-generated service registrations");
        sb.AppendLine($"    /// Found {services.Count} service(s)");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static class CatgaGeneratedServiceRegistrations");
        sb.AppendLine("    {");
        sb.AppendLine("        /// <summary>");
        sb.AppendLine("        /// Registers all auto-discovered services");
        sb.AppendLine("        /// Supports both interface and concrete type registration");
        sb.AppendLine("        /// </summary>");
        sb.AppendLine("        public static IServiceCollection AddGeneratedServices(this IServiceCollection services)");
        sb.AppendLine("        {");

        if (services.Count == 0)
        {
            sb.AppendLine("            // No services to register");
        }
        else
        {
            var grouped = services.GroupBy(s => s.Lifetime);
            foreach (var group in grouped.OrderBy(g => g.Key))
            {
                sb.AppendLine($"            // {group.Key} lifetime services");
                foreach (var service in group)
                {
                    var methodName = group.Key switch
                    {
                        "Singleton" => "AddSingleton",
                        "Transient" => "AddTransient",
                        _ => "AddScoped"
                    };

                    if (service.Interfaces.Count > 0)
                    {
                        // Has ServiceType: Register as ServiceType -> ImplType
                        foreach (var interfaceType in service.Interfaces)
                        {
                            sb.AppendLine($"            services.{methodName}<{interfaceType}, {service.ImplementationType}>();");
                        }
                        // Also register concrete type
                        sb.AppendLine($"            services.{methodName}<{service.ImplementationType}>();");
                    }
                    else
                    {
                        // No ServiceType: Only register concrete type
                        sb.AppendLine($"            services.{methodName}<{service.ImplementationType}>();");
                    }
                }
                sb.AppendLine();
            }
        }

        sb.AppendLine("            return services;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private const string AttributeSource = @"// <auto-generated/>
#nullable enable

namespace Catga;

/// <summary>
/// Service registration attribute
/// Rules:
/// 1. If ServiceType specified: Register as ServiceType -> ImplType
/// 2. If ServiceType not specified: Register only as ImplType (concrete type)
/// 3. ImplType defaults to the marked class itself
/// </summary>
[System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
public sealed class CatgaServiceAttribute : System.Attribute
{
    /// <summary>
    /// Service lifetime (default: Scoped)
    /// </summary>
    public ServiceLifetime Lifetime { get; set; } = ServiceLifetime.Scoped;

    /// <summary>
    /// Service type (interface) to register
    /// REQUIRED if you want interface registration
    /// If not specified, only registers concrete type
    /// </summary>
    public System.Type? ServiceType { get; set; }

    /// <summary>
    /// Implementation type
    /// If not specified, uses the marked class itself
    /// </summary>
    public System.Type? ImplType { get; set; }

    /// <summary>
    /// Whether to auto-register this service (default: true)
    /// </summary>
    public bool AutoRegister { get; set; } = true;

    public CatgaServiceAttribute() { }

    public CatgaServiceAttribute(ServiceLifetime lifetime)
    {
        Lifetime = lifetime;
    }
}

/// <summary>
/// Service lifetime
/// </summary>
public enum ServiceLifetime
{
    Singleton = 0,
    Scoped = 1,
    Transient = 2
}
";

    private sealed class ServiceInfo
    {
        public string ImplementationType { get; }
        public List<string> Interfaces { get; }
        public string Lifetime { get; }

        public ServiceInfo(string implementationType, List<string> interfaces, string lifetime)
        {
            ImplementationType = implementationType;
            Interfaces = interfaces;
            Lifetime = lifetime;
        }
    }
}

