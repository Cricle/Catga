using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using Catga.Flow.Dsl;
using Catga.Abstractions;
using System.Diagnostics.CodeAnalysis;
using Catga.DependencyInjection;

namespace Catga.Flow.Extensions;

/// <summary>
/// Service collection extensions for Flow DSL registration.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Register Flow DSL services with InMemory storage (default for development/testing).
    /// </summary>
    public static IServiceCollection AddFlowDsl(this IServiceCollection services, Action<FlowDslOptions>? configure = null)
        => services.AddFlowDslCore(configure);

    /// <summary>
    /// Register core Flow DSL services without storage implementation.
    /// Must be called after registering an IDslFlowStore implementation.
    /// </summary>
    public static IServiceCollection AddFlowDslCore(this IServiceCollection services, Action<FlowDslOptions>? configure = null)
    {
        var options = new FlowDslOptions();
        configure?.Invoke(options);

        // Register mediator and pipeline behaviors
        services.AddCatga();

        // Auto-register flow configurations using source-generated method
        if (options.AutoRegisterFlows)
        {
            services.AddGeneratedFlows();
        }

        // Register metrics if provided
        if (options.MetricsProvider != null)
        {
            services.AddSingleton(options.MetricsProvider);
        }

        return services;
    }


    /// <summary>
    /// Register a specific flow configuration.
    /// </summary>
    public static IServiceCollection AddFlow<
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] TState,
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TFlow>(
        this IServiceCollection services,
        ServiceLifetime lifetime = ServiceLifetime.Scoped)
        where TState : class, IFlowState, new()
        where TFlow : FlowConfig<TState>, new()
    {
        // Register flow configuration
        services.Add(new ServiceDescriptor(typeof(FlowConfig<TState>), typeof(TFlow), lifetime));
        services.Add(new ServiceDescriptor(typeof(TFlow), typeof(TFlow), lifetime));

        // Register flow executor
        services.AddTransient<DslFlowExecutor<TState, TFlow>>();

        return services;
    }

    /// <summary>
    /// Register all source-generated flow configurations.
    /// This method is more efficient than reflection-based registration.
    /// </summary>
    public static IServiceCollection AddAllGeneratedFlows(this IServiceCollection services)
    {
        // This method is generated by FlowDslRegistrationGenerator
        return services.AddGeneratedFlows();
    }

    /// <summary>
    /// Fallback registration when source generator output is unavailable (e.g., during design-time builds).
    /// The generator normally emits this method; this stub ensures compilation safety.
    /// </summary>
    public static IServiceCollection AddGeneratedFlows(this IServiceCollection services)
    {
        return services;
    }

    /// <summary>
    /// Create a flow executor directly for testing or specific scenarios.
    /// </summary>
    public static DslFlowExecutor<TState, TFlow> CreateFlowExecutor<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] TState, TFlow>(
        this IServiceProvider provider)
        where TState : class, IFlowState, new()
        where TFlow : FlowConfig<TState>, new()
    {
        var mediator = provider.GetRequiredService<ICatgaMediator>();
        var store = provider.GetRequiredService<IDslFlowStore>();
        var config = provider.GetService<TFlow>() ?? new TFlow();

        return new DslFlowExecutor<TState, TFlow>(mediator, store, config);
    }

    /// <summary>
    /// Register Flow DSL services with Redis storage.
    /// </summary>
    public static IServiceCollection AddFlowDslWithRedis(this IServiceCollection services, string connectionString, Action<FlowDslRedisOptions>? configure = null)
    {
        var options = new FlowDslRedisOptions();
        configure?.Invoke(options);
        // Redis store registration handled by Catga.Persistence.Redis package
        return services.AddFlowDslCore(opt =>
        {
            opt.AutoRegisterFlows = options.AutoRegisterFlows;
            opt.EnableMetrics = options.EnableMetrics;
        });
    }

    /// <summary>
    /// Register Flow DSL services with NATS storage.
    /// </summary>
    public static IServiceCollection AddFlowDslWithNats(this IServiceCollection services, string connectionString, Action<FlowDslNatsOptions>? configure = null)
    {
        var options = new FlowDslNatsOptions();
        configure?.Invoke(options);
        // NATS store registration handled by Catga.Persistence.Nats package
        return services.AddFlowDslCore(opt =>
        {
            opt.AutoRegisterFlows = options.AutoRegisterFlows;
            opt.EnableMetrics = options.EnableMetrics;
        });
    }

    /// <summary>
    /// Configure Flow DSL with fluent builder pattern.
    /// </summary>
    public static IServiceCollection ConfigureFlowDsl(this IServiceCollection services, Action<IFlowDslBuilder> configure)
    {
        var builder = new FlowDslBuilder(services);
        configure(builder);
        return services;
    }

    /// <summary>
    /// Configure Flow DSL settings from configuration.
    /// </summary>
    public static IServiceCollection AddFlowDslFromConfiguration(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var flowConfig = configuration.GetSection("FlowDsl");

        var options = new FlowDslOptions
        {
            AutoRegisterFlows = GetBool(flowConfig, "AutoRegisterFlows", true),
            EnableMetrics = GetBool(flowConfig, "EnableMetrics", false)
        };

        return services.AddFlowDslCore(opt => ApplyOptions(opt, options));
    }

    // Helper methods
    private static void ApplyOptions(FlowDslOptions target, FlowDslOptions source)
    {
        target.AutoRegisterFlows = source.AutoRegisterFlows;
        target.EnableMetrics = source.EnableMetrics;
        target.MetricsProvider = source.MetricsProvider;
        target.MaxRetryAttempts = source.MaxRetryAttempts;
        target.StepTimeout = source.StepTimeout;
    }

    private static bool GetBool(IConfigurationSection section, string key, bool defaultValue)
    {
        var value = section[key];
        if (bool.TryParse(value, out var parsed))
        {
            return parsed;
        }

        return defaultValue;
    }
}

/// <summary>
/// Options for Flow DSL configuration.
/// </summary>
public class FlowDslOptions
{
    /// <summary>
    /// Automatically register all source-generated FlowConfig classes.
    /// </summary>
    public bool AutoRegisterFlows { get; set; } = true;

    /// <summary>
    /// Enable flow execution metrics.
    /// </summary>
    public bool EnableMetrics { get; set; } = false;

    /// <summary>
    /// Custom metrics provider.
    /// </summary>
    public object? MetricsProvider { get; set; }

    /// <summary>
    /// Maximum retry attempts for failed steps.
    /// </summary>
    public int MaxRetryAttempts { get; set; } = 3;

    /// <summary>
    /// Timeout for individual flow steps.
    /// </summary>
    public TimeSpan StepTimeout { get; set; } = TimeSpan.FromMinutes(5);
}

/// <summary>
/// Options for Redis-backed Flow DSL.
/// </summary>
public class FlowDslRedisOptions
{
    public string RedisPrefix { get; set; } = "flowdsl:";
    public bool AutoRegisterFlows { get; set; } = true;
    public bool EnableMetrics { get; set; } = false;
}

/// <summary>
/// Options for NATS-backed Flow DSL.
/// </summary>
public class FlowDslNatsOptions
{
    public string NatsBucket { get; set; } = "flowdsl";
    public bool AutoRegisterFlows { get; set; } = true;
    public bool EnableMetrics { get; set; } = false;
}

/// <summary>
/// Fluent builder interface for Flow DSL configuration.
/// </summary>
public interface IFlowDslBuilder
{
    IFlowDslBuilder UseRedisStorage(string connectionString, string prefix = "flowdsl:");
    IFlowDslBuilder UseNatsStorage(string connectionString, string bucket = "flowdsl");
    IFlowDslBuilder RegisterGeneratedFlows();
    IFlowDslBuilder RegisterFlow<TState, TFlow>() where TState : class, IFlowState, new() where TFlow : FlowConfig<TState>, new();
    IFlowDslBuilder WithMetrics();
    IFlowDslBuilder WithRetryPolicy(int maxAttempts, TimeSpan retryDelay);
    IFlowDslBuilder WithStepTimeout(TimeSpan timeout);
}

/// <summary>
/// Default implementation of IFlowDslBuilder.
/// </summary>
internal class FlowDslBuilder : IFlowDslBuilder
{
    private readonly IServiceCollection _services;

    public FlowDslBuilder(IServiceCollection services) => _services = services;

    public IFlowDslBuilder UseRedisStorage(string connectionString, string prefix = "flowdsl:")
    {
        // Redis store registration handled by persistence package
        return this;
    }

    public IFlowDslBuilder UseNatsStorage(string connectionString, string bucket = "flowdsl")
    {
        // NATS store registration handled by persistence package
        return this;
    }

    public IFlowDslBuilder RegisterGeneratedFlows()
    {
        _services.AddGeneratedFlows();
        return this;
    }

    public IFlowDslBuilder RegisterFlow<TState, TFlow>() where TState : class, IFlowState, new() where TFlow : FlowConfig<TState>, new()
    {
        _services.AddFlow<TState, TFlow>();
        return this;
    }

    public IFlowDslBuilder WithMetrics()
    {
        // Metrics configuration
        return this;
    }

    public IFlowDslBuilder WithRetryPolicy(int maxAttempts, TimeSpan retryDelay)
    {
        // Retry policy configuration
        return this;
    }

    public IFlowDslBuilder WithStepTimeout(TimeSpan timeout)
    {
        // Timeout configuration
        return this;
    }
}

