using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using Catga.Flow.Dsl;
using Catga.Abstractions;
using System.Diagnostics.CodeAnalysis;
using Catga.DependencyInjection;

namespace Catga.Flow.Extensions;

/// <summary>
/// Service collection extensions for Flow DSL registration.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Add Flow DSL with InMemory storage (for development/testing).
    /// </summary>
    public static IServiceCollection AddFlowDsl(this IServiceCollection services, Action<FlowDslOptions>? configure = null)
    {
        var options = new FlowDslOptions();
        configure?.Invoke(options);

        // Register core services - InMemory store requires Catga.Persistence.InMemory package
        // Users should call AddInMemoryPersistence() from that package before AddFlowDsl()
        // or use the combined method from the persistence package

        // Register mediator and pipeline behaviors
        services.AddCatga();

        // Auto-register flow configurations using source-generated method
        if (options.AutoRegisterFlows)
        {
            services.AddGeneratedFlows();
        }

        // Register metrics if provided
        if (options.MetricsProvider != null)
        {
            services.AddSingleton(options.MetricsProvider);
        }

        return services;
    }

    /// <summary>
    /// Add Flow DSL with Redis storage (for production).
    /// </summary>
    public static IServiceCollection AddFlowDslWithRedis(
        this IServiceCollection services,
        string connectionString,
        Action<FlowDslOptions>? configure = null)
    {
        // Avoid hard dependency on Redis package in core library
        throw new NotSupportedException("AddFlowDslWithRedis requires Catga.Persistence.Redis package. Reference that package and use its extension methods.");
    }

    /// <summary>
    /// Add Flow DSL with NATS storage (for event-driven systems).
    /// </summary>
    public static IServiceCollection AddFlowDslWithNats(
        this IServiceCollection services,
        string natsUrl,
        Action<FlowDslOptions>? configure = null)
    {
        // Avoid hard dependency on NATS package in core library
        throw new NotSupportedException("AddFlowDslWithNats requires Catga.Persistence.Nats package. Reference that package and use its extension methods.");
    }

    /// <summary>
    /// Register a specific flow configuration.
    /// </summary>
    public static IServiceCollection AddFlow<
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] TState,
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TFlow>(
        this IServiceCollection services,
        ServiceLifetime lifetime = ServiceLifetime.Scoped)
        where TState : class, IFlowState, new()
        where TFlow : FlowConfig<TState>, new()
    {
        // Register flow configuration
        services.Add(new ServiceDescriptor(typeof(FlowConfig<TState>), typeof(TFlow), lifetime));
        services.Add(new ServiceDescriptor(typeof(TFlow), typeof(TFlow), lifetime));

        // Register flow executor
        services.AddTransient<DslFlowExecutor<TState, TFlow>>();

        return services;
    }

    /// <summary>
    /// Register all source-generated flow configurations.
    /// This method is more efficient than reflection-based registration.
    /// </summary>
    public static IServiceCollection AddAllGeneratedFlows(this IServiceCollection services)
    {
        // This method is generated by FlowDslRegistrationGenerator
        return services.AddGeneratedFlows();
    }

    /// <summary>
    /// Fallback registration when source generator output is unavailable (e.g., during design-time builds).
    /// The generator normally emits this method; this stub ensures compilation safety.
    /// </summary>
    public static IServiceCollection AddGeneratedFlows(this IServiceCollection services)
    {
        return services;
    }

    /// <summary>
    /// Create a flow executor directly for testing or specific scenarios.
    /// </summary>
    public static DslFlowExecutor<TState, TFlow> CreateFlowExecutor<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] TState, TFlow>(
        this IServiceProvider provider)
        where TState : class, IFlowState, new()
        where TFlow : FlowConfig<TState>, new()
    {
        var mediator = provider.GetRequiredService<ICatgaMediator>();
        var store = provider.GetRequiredService<IDslFlowStore>();
        var config = provider.GetService<TFlow>() ?? new TFlow();

        return new DslFlowExecutor<TState, TFlow>(mediator, store, config);
    }

    /// <summary>
    /// Configure Flow DSL settings from configuration.
    /// </summary>
    public static IServiceCollection AddFlowDslFromConfiguration(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var flowConfig = configuration.GetSection("FlowDsl");
        var storageType = flowConfig["Storage"] ?? "InMemory";

        var options = new FlowDslOptions
        {
            AutoRegisterFlows = GetBool(flowConfig, "AutoRegisterFlows", true),
            RedisPrefix = flowConfig["RedisPrefix"] ?? "dslflow:",
            NatsBucket = flowConfig["NatsBucket"] ?? "dslflows",
            EnableMetrics = GetBool(flowConfig, "EnableMetrics", false)
        };

        return services.AddFlowDsl(opt => ApplyOptions(opt, options));
    }

    // Helper methods
    private static void ApplyOptions(FlowDslOptions target, FlowDslOptions source)
    {
        target.AutoRegisterFlows = source.AutoRegisterFlows;
        target.RedisPrefix = source.RedisPrefix;
        target.NatsBucket = source.NatsBucket;
        target.EnableMetrics = source.EnableMetrics;
        target.MetricsProvider = source.MetricsProvider;
        target.MaxRetryAttempts = source.MaxRetryAttempts;
        target.StepTimeout = source.StepTimeout;
    }

    private static bool GetBool(IConfigurationSection section, string key, bool defaultValue)
    {
        var value = section[key];
        if (bool.TryParse(value, out var parsed))
        {
            return parsed;
        }

        return defaultValue;
    }
}

/// <summary>
/// Options for Flow DSL configuration.
/// </summary>
public class FlowDslOptions
{
    /// <summary>
    /// Automatically register all source-generated FlowConfig classes.
    /// </summary>
    public bool AutoRegisterFlows { get; set; } = true;

    /// <summary>
    /// Redis key prefix for flow storage.
    /// </summary>
    public string RedisPrefix { get; set; } = "dslflow:";

    /// <summary>
    /// NATS bucket name for flow storage.
    /// </summary>
    public string NatsBucket { get; set; } = "dslflows";

    /// <summary>
    /// Storage provider type: InMemory, Redis, or Nats.
    /// </summary>
    public string StorageType { get; set; } = "InMemory";

    /// <summary>
    /// Redis connection string for Redis storage.
    /// </summary>
    public string RedisConnectionString { get; set; } = "localhost:6379";

    /// <summary>
    /// NATS connection URL for NATS storage.
    /// </summary>
    public string NatsUrl { get; set; } = "nats://localhost:4222";

    /// <summary>
    /// Enable flow execution metrics.
    /// </summary>
    public bool EnableMetrics { get; set; } = false;

    /// <summary>
    /// Custom metrics provider.
    /// </summary>
    public object? MetricsProvider { get; set; }

    /// <summary>
    /// Maximum retry attempts for failed steps.
    /// </summary>
    public int MaxRetryAttempts { get; set; } = 3;

    /// <summary>
    /// Timeout for individual flow steps.
    /// </summary>
    public TimeSpan StepTimeout { get; set; } = TimeSpan.FromMinutes(5);
}

/// <summary>
/// Builder extensions for fluent configuration.
/// </summary>
public static class FlowDslBuilderExtensions
{
    /// <summary>
    /// Configure Flow DSL with a builder pattern.
    /// </summary>
    public static IServiceCollection ConfigureFlowDsl(
        this IServiceCollection services,
        Action<IFlowDslBuilder> configure)
    {
        var builder = new FlowDslBuilder(services);
        configure(builder);
        return builder.Build();
    }
}

/// <summary>
/// Fluent builder for Flow DSL configuration.
/// </summary>
public interface IFlowDslBuilder
{
    /// <summary>Use InMemory storage.</summary>
    IFlowDslBuilder UseInMemoryStorage();

    /// <summary>Use Redis storage.</summary>
    IFlowDslBuilder UseRedisStorage(string connectionString, string? prefix = null);

    /// <summary>Use NATS storage.</summary>
    IFlowDslBuilder UseNatsStorage(string natsUrl, string? bucket = null);

    /// <summary>Register all source-generated flows.</summary>
    IFlowDslBuilder RegisterGeneratedFlows();

    /// <summary>Register a specific flow.</summary>
    IFlowDslBuilder RegisterFlow<
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] TState,
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TFlow>()
        where TState : class, IFlowState, new()
        where TFlow : FlowConfig<TState>, new();

    /// <summary>Enable metrics collection.</summary>
    IFlowDslBuilder WithMetrics(object? metricsProvider = null);

    /// <summary>Configure retry policy.</summary>
    IFlowDslBuilder WithRetryPolicy(int maxAttempts, TimeSpan? retryDelay = null);

    /// <summary>Set step timeout.</summary>
    IFlowDslBuilder WithStepTimeout(TimeSpan timeout);
}

internal class FlowDslBuilder : IFlowDslBuilder
{
    private readonly IServiceCollection _services;
    private readonly FlowDslOptions _options = new();
    private StorageType _storageType = StorageType.InMemory;
    private string? _connectionString;

    public FlowDslBuilder(IServiceCollection services)
    {
        _services = services;
    }

    public IFlowDslBuilder UseInMemoryStorage()
    {
        _storageType = StorageType.InMemory;
        return this;
    }

    public IFlowDslBuilder UseRedisStorage(string connectionString, string? prefix = null)
    {
        _storageType = StorageType.Redis;
        _connectionString = connectionString;
        if (prefix != null) _options.RedisPrefix = prefix;
        return this;
    }

    public IFlowDslBuilder UseNatsStorage(string natsUrl, string? bucket = null)
    {
        _storageType = StorageType.Nats;
        _connectionString = natsUrl;
        if (bucket != null) _options.NatsBucket = bucket;
        return this;
    }

    public IFlowDslBuilder RegisterGeneratedFlows()
    {
        _options.AutoRegisterFlows = true;
        return this;
    }

    public IFlowDslBuilder RegisterFlow<
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] TState,
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TFlow>()
        where TState : class, IFlowState, new()
        where TFlow : FlowConfig<TState>, new()
    {
        _services.AddFlow<TState, TFlow>();
        return this;
    }

    public IFlowDslBuilder WithMetrics(object? metricsProvider = null)
    {
        _options.EnableMetrics = true;
        _options.MetricsProvider = metricsProvider;
        return this;
    }

    public IFlowDslBuilder WithRetryPolicy(int maxAttempts, TimeSpan? retryDelay = null)
    {
        _options.MaxRetryAttempts = maxAttempts;
        return this;
    }

    public IFlowDslBuilder WithStepTimeout(TimeSpan timeout)
    {
        _options.StepTimeout = timeout;
        return this;
    }

    public IServiceCollection Build()
    {
        return _storageType switch
        {
            StorageType.Redis => _services.AddFlowDslWithRedis(_connectionString!, opt => ApplyOptions(opt)),
            StorageType.Nats => _services.AddFlowDslWithNats(_connectionString!, opt => ApplyOptions(opt)),
            _ => _services.AddFlowDsl(opt => ApplyOptions(opt))
        };
    }

    private void ApplyOptions(FlowDslOptions opt)
    {
        opt.AutoRegisterFlows = _options.AutoRegisterFlows;
        opt.RedisPrefix = _options.RedisPrefix;
        opt.NatsBucket = _options.NatsBucket;
        opt.EnableMetrics = _options.EnableMetrics;
        opt.MetricsProvider = _options.MetricsProvider;
        opt.MaxRetryAttempts = _options.MaxRetryAttempts;
        opt.StepTimeout = _options.StepTimeout;
    }

    private enum StorageType
    {
        InMemory,
        Redis,
        Nats
    }
}
