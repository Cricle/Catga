using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Configuration;
using Catga.Flow.Dsl;
using Catga.Abstractions;
using System.Diagnostics.CodeAnalysis;
using Catga.DependencyInjection;

namespace Catga.Flow.Extensions;

/// <summary>
/// Service collection extensions for Flow DSL registration.
/// </summary>
public static class ServiceCollectionExtensions
{
    /// <summary>
    /// Register core Flow DSL services without storage implementation.
    /// Must be called after registering an IDslFlowStore implementation.
    /// </summary>
    public static IServiceCollection AddFlowDslCore(this IServiceCollection services, Action<FlowDslOptions>? configure = null)
    {
        var options = new FlowDslOptions();
        configure?.Invoke(options);

        // Register mediator and pipeline behaviors
        services.AddCatga();

        // Auto-register flow configurations using source-generated method
        if (options.AutoRegisterFlows)
        {
            services.AddGeneratedFlows();
        }

        // Register metrics if provided
        if (options.MetricsProvider != null)
        {
            services.AddSingleton(options.MetricsProvider);
        }

        return services;
    }


    /// <summary>
    /// Register a specific flow configuration.
    /// </summary>
    public static IServiceCollection AddFlow<
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] TState,
        [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TFlow>(
        this IServiceCollection services,
        ServiceLifetime lifetime = ServiceLifetime.Scoped)
        where TState : class, IFlowState, new()
        where TFlow : FlowConfig<TState>, new()
    {
        // Register flow configuration
        services.Add(new ServiceDescriptor(typeof(FlowConfig<TState>), typeof(TFlow), lifetime));
        services.Add(new ServiceDescriptor(typeof(TFlow), typeof(TFlow), lifetime));

        // Register flow executor
        services.AddTransient<DslFlowExecutor<TState, TFlow>>();

        return services;
    }

    /// <summary>
    /// Register all source-generated flow configurations.
    /// This method is more efficient than reflection-based registration.
    /// </summary>
    public static IServiceCollection AddAllGeneratedFlows(this IServiceCollection services)
    {
        // This method is generated by FlowDslRegistrationGenerator
        return services.AddGeneratedFlows();
    }

    /// <summary>
    /// Fallback registration when source generator output is unavailable (e.g., during design-time builds).
    /// The generator normally emits this method; this stub ensures compilation safety.
    /// </summary>
    public static IServiceCollection AddGeneratedFlows(this IServiceCollection services)
    {
        return services;
    }

    /// <summary>
    /// Create a flow executor directly for testing or specific scenarios.
    /// </summary>
    public static DslFlowExecutor<TState, TFlow> CreateFlowExecutor<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)] TState, TFlow>(
        this IServiceProvider provider)
        where TState : class, IFlowState, new()
        where TFlow : FlowConfig<TState>, new()
    {
        var mediator = provider.GetRequiredService<ICatgaMediator>();
        var store = provider.GetRequiredService<IDslFlowStore>();
        var config = provider.GetService<TFlow>() ?? new TFlow();

        return new DslFlowExecutor<TState, TFlow>(mediator, store, config);
    }

    /// <summary>
    /// Configure Flow DSL settings from configuration.
    /// </summary>
    public static IServiceCollection AddFlowDslFromConfiguration(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        var flowConfig = configuration.GetSection("FlowDsl");

        var options = new FlowDslOptions
        {
            AutoRegisterFlows = GetBool(flowConfig, "AutoRegisterFlows", true),
            EnableMetrics = GetBool(flowConfig, "EnableMetrics", false)
        };

        return services.AddFlowDslCore(opt => ApplyOptions(opt, options));
    }

    // Helper methods
    private static void ApplyOptions(FlowDslOptions target, FlowDslOptions source)
    {
        target.AutoRegisterFlows = source.AutoRegisterFlows;
        target.EnableMetrics = source.EnableMetrics;
        target.MetricsProvider = source.MetricsProvider;
        target.MaxRetryAttempts = source.MaxRetryAttempts;
        target.StepTimeout = source.StepTimeout;
    }

    private static bool GetBool(IConfigurationSection section, string key, bool defaultValue)
    {
        var value = section[key];
        if (bool.TryParse(value, out var parsed))
        {
            return parsed;
        }

        return defaultValue;
    }
}

/// <summary>
/// Options for Flow DSL configuration.
/// </summary>
public class FlowDslOptions
{
    /// <summary>
    /// Automatically register all source-generated FlowConfig classes.
    /// </summary>
    public bool AutoRegisterFlows { get; set; } = true;

    /// <summary>
    /// Enable flow execution metrics.
    /// </summary>
    public bool EnableMetrics { get; set; } = false;

    /// <summary>
    /// Custom metrics provider.
    /// </summary>
    public object? MetricsProvider { get; set; }

    /// <summary>
    /// Maximum retry attempts for failed steps.
    /// </summary>
    public int MaxRetryAttempts { get; set; } = 3;

    /// <summary>
    /// Timeout for individual flow steps.
    /// </summary>
    public TimeSpan StepTimeout { get; set; } = TimeSpan.FromMinutes(5);
}

