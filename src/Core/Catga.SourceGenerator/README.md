# Catga 源生成器

## 📖 简介

Catga 源生成器在**编译时**自动发现并生成 Handler 注册代码，实现：
- ✨ **零手动配置** - 实现接口即自动注册
- 🚀 **编译时生成** - 零运行时开销
- 🎯 **100% AOT 兼容** - 无反射，完全静态化
- 💎 **类型安全** - 编译时验证

## 🚀 快速开始

### 1. 添加引用

```xml
<ItemGroup>
  <ProjectReference Include="Catga.SourceGenerator.csproj"
                    OutputItemType="Analyzer"
                    ReferenceOutputAssembly="false" />
</ItemGroup>
```

### 2. 编写 Handler

```csharp
// 🎯 无需任何特性标记，自动发现！
public class CreateUserHandler : IRequestHandler<CreateUserCommand, UserResponse>
{
    public Task<CatgaResult<UserResponse>> HandleAsync(
        CreateUserCommand request,
        CancellationToken cancellationToken = default)
    {
        // 业务逻辑
    }
}
```

### 3. 注册 Handler

```csharp
// ✨ 一行代码，自动注册所有 Handler
builder.Services.AddGeneratedHandlers();
```

## 🎯 工作原理

### 编译时

源生成器会扫描所有实现了以下接口的类：
- `IRequestHandler<TRequest, TResponse>`
- `IRequestHandler<TRequest>`
- `IEventHandler<TEvent>`

生成的代码示例：

```csharp
// <auto-generated/>
namespace Catga.DependencyInjection;

public static class CatgaGeneratedHandlerRegistrations
{
    public static IServiceCollection AddGeneratedHandlers(this IServiceCollection services)
    {
        // Scoped lifetime handlers
        services.AddScoped<IRequestHandler<CreateUserCommand, UserResponse>, CreateUserHandler>();
        services.AddScoped<IRequestHandler<GetUserQuery, UserResponse>, GetUserHandler>();
        services.AddScoped<IEventHandler<UserCreatedEvent>, UserCreatedEventHandler>();

        return services;
    }
}
```

### 运行时

调用 `AddGeneratedHandlers()` 时，直接使用生成的代码，**零反射、零扫描**！

## 🎨 高级用法

### 1. 自定义生命周期

```csharp
// Singleton（单例）
[CatgaHandler(Lifetime = HandlerLifetime.Singleton)]
public class CachedDataHandler : IRequestHandler<GetCachedDataQuery, DataResponse>
{
    // 单例 Handler，适合无状态、线程安全的场景
}

// Transient（每次创建新实例）
[CatgaHandler(Lifetime = HandlerLifetime.Transient)]
public class TempHandler : IRequestHandler<TempCommand, TempResponse>
{
    // 瞬态 Handler，每次请求创建新实例
}

// Scoped（默认，作用域内单例）
public class OrderHandler : IRequestHandler<CreateOrderCommand, OrderResponse>
{
    // 默认 Scoped，一次请求内共享实例
}
```

### 2. 禁用自动注册

```csharp
// 手动注册（不使用源生成器）
[CatgaHandler(AutoRegister = false)]
public class ManualHandler : IRequestHandler<ManualCommand, ManualResponse>
{
    // 需要手动注册: services.AddScoped<IRequestHandler<ManualCommand, ManualResponse>, ManualHandler>();
}
```

**使用场景**:
- 需要复杂的注册逻辑
- 需要条件注册
- 需要自定义工厂方法

### 3. 组合使用

```csharp
// ✨ 自动注册（源生成器）
services.AddGeneratedHandlers();

// 🔧 手动注册特殊 Handler
services.AddSingleton<IRequestHandler<SpecialCommand, SpecialResponse>>(sp =>
    new SpecialHandler(sp.GetRequiredService<ISpecialDependency>()));
```

## 📊 性能对比

| 方式 | 启动时间 | 运行时开销 | AOT 兼容 |
|------|---------|----------|---------|
| **源生成器** | ~50ms | 0 | ✅ 100% |
| 反射扫描 | ~500ms | 高 | ❌ 不兼容 |
| 手动注册 | ~50ms | 0 | ✅ 100% |

## 🔍 调试生成的代码

生成的代码位于：
```
obj/Debug/net9.0/generated/Catga.SourceGenerator/CatgaHandlerGenerator/CatgaGeneratedHandlerRegistrations.g.cs
```

查看生成的代码：
```bash
# 编译后查看
cat obj/Debug/net9.0/generated/Catga.SourceGenerator/CatgaHandlerGenerator/CatgaGeneratedHandlerRegistrations.g.cs
```

## 🎓 最佳实践

### 1. 保持 Handler 简单

```csharp
// ✅ 好：简单、单一职责
public class CreateUserHandler : IRequestHandler<CreateUserCommand, UserResponse>
{
    private readonly IUserRepository _repository;
    private readonly ILogger<CreateUserHandler> _logger;

    public CreateUserHandler(IUserRepository repository, ILogger<CreateUserHandler> logger)
    {
        _repository = repository;
        _logger = logger;
    }

    public async Task<CatgaResult<UserResponse>> HandleAsync(CreateUserCommand cmd, CancellationToken ct)
    {
        _logger.LogInformation("Creating user: {Username}", cmd.Username);
        var user = await _repository.CreateAsync(cmd, ct);
        return CatgaResult<UserResponse>.Success(new UserResponse(user.Id, user.Username));
    }
}
```

### 2. 合理选择生命周期

| 生命周期 | 适用场景 | 注意事项 |
|---------|---------|---------|
| **Scoped** (默认) | 大多数业务逻辑 | 一次请求内共享 |
| **Singleton** | 无状态、线程安全 | 避免状态，注意线程安全 |
| **Transient** | 需要独立状态 | 每次创建，开销稍高 |

### 3. 命名约定

```csharp
// ✅ 推荐：{操作}{实体}Handler
public class CreateUserHandler : IRequestHandler<CreateUserCommand, UserResponse> { }
public class GetUserHandler : IRequestHandler<GetUserQuery, UserResponse> { }
public class DeleteUserHandler : IRequestHandler<DeleteUserCommand> { }

// ✅ 推荐：{实体}{事件}Handler
public class UserCreatedEventHandler : IEventHandler<UserCreatedEvent> { }
public class OrderShippedEventHandler : IEventHandler<OrderShippedEvent> { }
```

## 🐛 常见问题

### Q: 为什么我的 Handler 没有被注册？

A: 检查以下几点：
1. Handler 是否实现了 `IRequestHandler` 或 `IEventHandler`？
2. Handler 类是否是 `public`？
3. 是否调用了 `AddGeneratedHandlers()`？
4. 是否设置了 `AutoRegister = false`？

### Q: 如何查看生成了哪些 Handler？

A: 查看生成的代码文件：
```
obj/Debug/net9.0/generated/Catga.SourceGenerator/CatgaHandlerGenerator/CatgaGeneratedHandlerRegistrations.g.cs
```

### Q: 源生成器会影响编译时间吗？

A: 影响极小（< 100ms），因为源生成器只在编译时运行一次。

### Q: 可以混合使用自动注册和手动注册吗？

A: 可以！先调用 `AddGeneratedHandlers()`，再手动注册特殊 Handler。

## 📚 相关文档

- [Catga 快速开始](../../QUICK_START.md)
- [架构说明](../../ARCHITECTURE.md)
- [示例项目](../../examples/)

---

**Catga 源生成器 - 编译时魔法，运行时零开销！** ✨

