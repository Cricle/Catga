using Catga.Flow.Dsl;
using Catga.Persistence.InMemory.Flow;
using Catga.Tests.PropertyTests.Generators;
using FsCheck;
using FsCheck.Xunit;
using Xunit;

namespace Catga.Tests.PropertyTests;

/// <summary>
/// InMemoryDslFlowStore 属性测试
/// 使用 FsCheck 进行属性测试验证
/// 
/// 注意: FsCheck.Xunit 的 [Property] 特性要求测试类有无参构造函数
/// </summary>
[Trait("Category", "Property")]
[Trait("Backend", "InMemory")]
public class InMemoryFlowStorePropertyTests
{
    /// <summary>
    /// Wrapper class to avoid ToString stack overflow in FsCheck
    /// </summary>
    private class FlowSnapshotWrapper
    {
        public FlowSnapshot<SimpleTestFlowState> Snapshot { get; }
        
        public FlowSnapshotWrapper(FlowSnapshot<SimpleTestFlowState> snapshot)
        {
            Snapshot = snapshot;
        }
        
        public override string ToString() => $"FlowSnapshot(FlowId={Snapshot.FlowId}, Status={Snapshot.Status})";
    }

    /// <summary>
    /// Helper to create a valid FlowSnapshot using simple generators
    /// </summary>
    private static Arbitrary<FlowSnapshotWrapper> SimpleFlowSnapshotArbitrary()
    {
        var gen = from id in Gen.Choose(1, 100000)
                  from amount in Gen.Choose(0, 100000)
                  from status in Gen.Elements("Pending", "Processing", "Completed", "Failed")
                  from flowStatus in Gen.Elements(
                      DslFlowStatus.Pending,
                      DslFlowStatus.Running,
                      DslFlowStatus.Completed,
                      DslFlowStatus.Failed)
                  select new FlowSnapshotWrapper(new FlowSnapshot<SimpleTestFlowState>
                  {
                      FlowId = $"flow-{id}",
                      State = new SimpleTestFlowState
                      {
                          OrderId = $"order-{id}",
                          Amount = amount,
                          Status = status
                      },
                      Position = FlowPosition.Initial,
                      Status = flowStatus,
                      CreatedAt = DateTime.UtcNow,
                      UpdatedAt = DateTime.UtcNow,
                      Version = 0
                  });
        return gen.ToArbitrary();
    }

    /// <summary>
    /// Helper to create a valid SimpleTestFlowState generator
    /// </summary>
    private static Arbitrary<SimpleTestFlowState> SimpleTestFlowStateArbitrary()
    {
        var gen = from id in Gen.Choose(1, 100000)
                  from amount in Gen.Choose(0, 100000)
                  from status in Gen.Elements("Pending", "Processing", "Completed", "Failed")
                  select new SimpleTestFlowState
                  {
                      OrderId = $"order-{id}",
                      Amount = amount,
                      Status = status
                  };
        return gen.ToArbitrary();
    }

    /// <summary>
    /// Helper to create a valid DslFlowStatus generator
    /// </summary>
    private static Arbitrary<DslFlowStatus> SimpleFlowStatusArbitrary()
    {
        return Gen.Elements(
            DslFlowStatus.Pending,
            DslFlowStatus.Running,
            DslFlowStatus.Suspended,
            DslFlowStatus.Compensating,
            DslFlowStatus.Completed,
            DslFlowStatus.Failed,
            DslFlowStatus.Cancelled
        ).ToArbitrary();
    }

    /// <summary>
    /// Property 10: FlowStore State Persistence
    /// 
    /// *For any* valid flow state, saving then loading SHALL return a state with identical 
    /// FlowId, FlowType, Status, Data, and CurrentStep.
    /// 
    /// **Validates: Requirements 5.16**
    /// 
    /// Feature: tdd-validation, Property 10: FlowStore State Persistence
    /// </summary>
    [Property(MaxTest = PropertyTestConfig.DefaultMaxTest)]
    public Property FlowStore_RoundTrip_PreservesAllFlowStateData()
    {
        return Prop.ForAll(
            SimpleFlowSnapshotArbitrary(),
            (wrapper) =>
            {
                // Skip null values generated by FsCheck
                if (wrapper == null) return true;
                
                var snapshot = wrapper.Snapshot;
                
                // Arrange
                var store = new InMemoryDslFlowStore();

                // Act
                var createResult = store.CreateAsync(snapshot).GetAwaiter().GetResult();
                var loaded = store.GetAsync<SimpleTestFlowState>(snapshot.FlowId).GetAwaiter().GetResult();

                // Assert - Verify round-trip consistency
                if (!createResult)
                {
                    return false;
                }

                if (loaded == null)
                {
                    return false;
                }

                // 1. FlowId is preserved
                if (loaded.FlowId != snapshot.FlowId)
                {
                    return false;
                }

                // 2. Status is preserved
                if (loaded.Status != snapshot.Status)
                {
                    return false;
                }

                // 3. Position is preserved (compare path arrays)
                if (loaded.Position.Path.Length != snapshot.Position.Path.Length)
                {
                    return false;
                }
                for (int i = 0; i < snapshot.Position.Path.Length; i++)
                {
                    if (loaded.Position.Path[i] != snapshot.Position.Path[i])
                    {
                        return false;
                    }
                }

                // 4. State data is preserved
                if (loaded.State.OrderId != snapshot.State.OrderId)
                {
                    return false;
                }

                if (loaded.State.Amount != snapshot.State.Amount)
                {
                    return false;
                }

                if (loaded.State.Status != snapshot.State.Status)
                {
                    return false;
                }

                // 5. CreatedAt is preserved (within tolerance for serialization)
                var timeDiff = Math.Abs((loaded.CreatedAt - snapshot.CreatedAt).TotalSeconds);
                if (timeDiff > 1)
                {
                    return false;
                }

                return true;
            });
    }

    /// <summary>
    /// Property 10 (Alternative): FlowStore Round-Trip with Update
    /// 
    /// *For any* flow state that is created and then updated, loading SHALL return 
    /// the updated state with all modifications preserved.
    /// 
    /// **Validates: Requirements 5.16**
    /// 
    /// Feature: tdd-validation, Property 10: FlowStore State Persistence (Update)
    /// </summary>
    [Property(MaxTest = PropertyTestConfig.DefaultMaxTest)]
    public Property FlowStore_UpdateThenLoad_PreservesUpdatedState()
    {
        return Prop.ForAll(
            SimpleFlowSnapshotArbitrary(),
            SimpleTestFlowStateArbitrary(),
            SimpleFlowStatusArbitrary(),
            (wrapper, newState, newStatus) =>
            {
                // Skip null values generated by FsCheck
                if (wrapper == null || newState == null) return true;
                
                var initialSnapshot = wrapper.Snapshot;
                
                // Arrange
                var store = new InMemoryDslFlowStore();
                
                // Create initial snapshot with version 0
                var snapshotV0 = new FlowSnapshot<SimpleTestFlowState>
                {
                    FlowId = initialSnapshot.FlowId,
                    State = initialSnapshot.State,
                    Position = initialSnapshot.Position,
                    Status = initialSnapshot.Status,
                    CreatedAt = initialSnapshot.CreatedAt,
                    UpdatedAt = initialSnapshot.UpdatedAt,
                    Version = 0
                };

                // Act - Create initial flow
                var createResult = store.CreateAsync(snapshotV0).GetAwaiter().GetResult();
                if (!createResult)
                {
                    return false;
                }

                // Update with new state and status
                var updatedSnapshot = new FlowSnapshot<SimpleTestFlowState>
                {
                    FlowId = initialSnapshot.FlowId,
                    State = newState,
                    Position = initialSnapshot.Position.Advance(),
                    Status = newStatus,
                    CreatedAt = initialSnapshot.CreatedAt,
                    UpdatedAt = DateTime.UtcNow,
                    Version = 1
                };

                var updateResult = store.UpdateAsync(updatedSnapshot).GetAwaiter().GetResult();
                if (!updateResult)
                {
                    return false;
                }

                var loaded = store.GetAsync<SimpleTestFlowState>(initialSnapshot.FlowId).GetAwaiter().GetResult();

                // Assert - Verify updated state is preserved
                if (loaded == null)
                {
                    return false;
                }

                // 1. FlowId is preserved
                if (loaded.FlowId != initialSnapshot.FlowId)
                {
                    return false;
                }

                // 2. New status is preserved
                if (loaded.Status != newStatus)
                {
                    return false;
                }

                // 3. New state data is preserved
                if (loaded.State.OrderId != newState.OrderId)
                {
                    return false;
                }

                if (loaded.State.Amount != newState.Amount)
                {
                    return false;
                }

                if (loaded.State.Status != newState.Status)
                {
                    return false;
                }

                return true;
            });
    }

    /// <summary>
    /// Property 10 (Data Integrity): FlowStore Preserves Complex Nested State
    /// 
    /// *For any* flow state with collections and nested data, saving then loading 
    /// SHALL preserve all data including collections.
    /// 
    /// **Validates: Requirements 5.16**
    /// 
    /// Feature: tdd-validation, Property 10: FlowStore State Persistence (Complex State)
    /// </summary>
    [Property(MaxTest = PropertyTestConfig.DefaultMaxTest)]
    public Property FlowStore_RoundTrip_PreservesComplexNestedState()
    {
        return Prop.ForAll(
            Gen.Choose(1, 100000).ToArbitrary(),
            Gen.Choose(0, 100000).ToArbitrary(),
            Gen.Choose(1, 10).ToArbitrary(),
            (flowIdNum, amount, itemCount) =>
            {
                // Arrange
                var store = new InMemoryDslFlowStore();
                var flowId = $"flow-{flowIdNum}";
                var items = Enumerable.Range(1, itemCount).Select(i => $"item-{i}").ToList();
                
                var state = new SimpleTestFlowStateWithItems
                {
                    OrderId = $"order-{flowIdNum}",
                    Amount = amount,
                    Status = "Processing",
                    Items = items
                };

                var snapshot = new FlowSnapshot<SimpleTestFlowStateWithItems>
                {
                    FlowId = flowId,
                    State = state,
                    Position = FlowPosition.Initial,
                    Status = DslFlowStatus.Running,
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow,
                    Version = 0
                };

                // Act
                var createResult = store.CreateAsync(snapshot).GetAwaiter().GetResult();
                var loaded = store.GetAsync<SimpleTestFlowStateWithItems>(flowId).GetAwaiter().GetResult();

                // Assert
                if (!createResult)
                {
                    return false;
                }

                if (loaded == null)
                {
                    return false;
                }

                // Verify collections are preserved
                if (loaded.State.Items.Count != state.Items.Count)
                {
                    return false;
                }

                for (int i = 0; i < state.Items.Count; i++)
                {
                    if (loaded.State.Items[i] != state.Items[i])
                    {
                        return false;
                    }
                }

                // Verify other fields
                if (loaded.State.OrderId != state.OrderId)
                {
                    return false;
                }

                if (loaded.State.Amount != state.Amount)
                {
                    return false;
                }

                if (loaded.State.Status != state.Status)
                {
                    return false;
                }

                return true;
            });
    }

    /// <summary>
    /// Property 10 (Idempotence): FlowStore Create is Idempotent for Same FlowId
    /// 
    /// *For any* flow ID, creating a flow twice with the same ID SHALL fail on the second attempt,
    /// and the original flow state SHALL remain unchanged.
    /// 
    /// **Validates: Requirements 5.16**
    /// 
    /// Feature: tdd-validation, Property 10: FlowStore State Persistence (Idempotence)
    /// </summary>
    [Property(MaxTest = PropertyTestConfig.DefaultMaxTest)]
    public Property FlowStore_DuplicateCreate_FailsAndPreservesOriginal()
    {
        return Prop.ForAll(
            SimpleFlowSnapshotArbitrary(),
            SimpleTestFlowStateArbitrary(),
            (wrapper, differentState) =>
            {
                // Skip null values generated by FsCheck
                if (wrapper == null || differentState == null) return true;
                
                var originalSnapshot = wrapper.Snapshot;
                
                // Arrange
                var store = new InMemoryDslFlowStore();

                // Act - Create original flow
                var firstCreate = store.CreateAsync(originalSnapshot).GetAwaiter().GetResult();
                if (!firstCreate)
                {
                    return false;
                }

                // Try to create another flow with the same ID but different state
                var duplicateSnapshot = new FlowSnapshot<SimpleTestFlowState>
                {
                    FlowId = originalSnapshot.FlowId,
                    State = differentState,
                    Position = FlowPosition.Initial,
                    Status = DslFlowStatus.Pending,
                    CreatedAt = DateTime.UtcNow,
                    UpdatedAt = DateTime.UtcNow,
                    Version = 0
                };

                var secondCreate = store.CreateAsync(duplicateSnapshot).GetAwaiter().GetResult();

                // Assert - Second create should fail
                if (secondCreate)
                {
                    return false;
                }

                // Original state should be preserved
                var loaded = store.GetAsync<SimpleTestFlowState>(originalSnapshot.FlowId).GetAwaiter().GetResult();
                if (loaded == null)
                {
                    return false;
                }

                // Verify original state is preserved
                if (loaded.State.OrderId != originalSnapshot.State.OrderId)
                {
                    return false;
                }

                if (loaded.State.Amount != originalSnapshot.State.Amount)
                {
                    return false;
                }

                return true;
            });
    }

    /// <summary>
    /// Property 10 (Delete): FlowStore Delete Removes Flow Completely
    /// 
    /// *For any* flow that is created and then deleted, loading SHALL return null.
    /// 
    /// **Validates: Requirements 5.16**
    /// 
    /// Feature: tdd-validation, Property 10: FlowStore State Persistence (Delete)
    /// </summary>
    [Property(MaxTest = PropertyTestConfig.DefaultMaxTest)]
    public Property FlowStore_DeleteThenLoad_ReturnsNull()
    {
        return Prop.ForAll(
            SimpleFlowSnapshotArbitrary(),
            (wrapper) =>
            {
                // Skip null values generated by FsCheck
                if (wrapper == null) return true;
                
                var snapshot = wrapper.Snapshot;
                
                // Arrange
                var store = new InMemoryDslFlowStore();

                // Act - Create and then delete
                var createResult = store.CreateAsync(snapshot).GetAwaiter().GetResult();
                if (!createResult)
                {
                    return false;
                }

                var deleteResult = store.DeleteAsync(snapshot.FlowId).GetAwaiter().GetResult();
                if (!deleteResult)
                {
                    return false;
                }

                var loaded = store.GetAsync<SimpleTestFlowState>(snapshot.FlowId).GetAwaiter().GetResult();

                // Assert - Should return null after delete
                return loaded == null;
            });
    }

    /// <summary>
    /// Property 11: FlowStore Checkpoint Consistency
    /// 
    /// *For any* flow with checkpoints (ForEach progress), restoring from a checkpoint 
    /// SHALL produce a state consistent with the checkpoint version.
    /// 
    /// This property tests that:
    /// 1. ForEach progress (checkpoint) can be saved and retrieved consistently
    /// 2. The checkpoint state preserves CurrentIndex, TotalCount, CompletedIndices, and FailedIndices
    /// 3. Multiple checkpoints for different steps are independent
    /// 
    /// **Validates: Requirements 5.17**
    /// 
    /// Feature: tdd-validation, Property 11: FlowStore Checkpoint Consistency
    /// </summary>
    [Property(MaxTest = PropertyTestConfig.DefaultMaxTest)]
    public Property FlowStore_Checkpoint_RestoresConsistentState()
    {
        // Create a generator for checkpoint test data
        var checkpointDataGen = from flowIdNum in Gen.Choose(1, 100000)
                                from stepIndex in Gen.Choose(0, 10)
                                from currentIndex in Gen.Choose(0, 100)
                                from totalCount in Gen.Choose(1, 100)
                                from completedCount in Gen.Choose(0, 50)
                                from failedCount in Gen.Choose(0, 10)
                                select new { flowIdNum, stepIndex, currentIndex, totalCount, completedCount, failedCount };

        return Prop.ForAll(
            checkpointDataGen.ToArbitrary(),
            (data) =>
            {
                // Arrange
                var store = new InMemoryDslFlowStore();
                var flowId = $"flow-{data.flowIdNum}";
                
                // Ensure counts are valid (completed + failed <= total)
                var actualCompletedCount = Math.Min(data.completedCount, data.totalCount);
                var actualFailedCount = Math.Min(data.failedCount, data.totalCount - actualCompletedCount);
                var actualCurrentIndex = Math.Min(data.currentIndex, data.totalCount - 1);
                
                // Create checkpoint (ForEach progress)
                var checkpoint = new ForEachProgress
                {
                    CurrentIndex = actualCurrentIndex,
                    TotalCount = data.totalCount,
                    CompletedIndices = Enumerable.Range(0, actualCompletedCount).ToList(),
                    FailedIndices = Enumerable.Range(actualCompletedCount, actualFailedCount).ToList()
                };

                // Act - Save checkpoint
                store.SaveForEachProgressAsync(flowId, data.stepIndex, checkpoint).GetAwaiter().GetResult();
                
                // Act - Restore checkpoint
                var restored = store.GetForEachProgressAsync(flowId, data.stepIndex).GetAwaiter().GetResult();

                // Assert - Verify checkpoint consistency
                if (restored == null)
                {
                    return false;
                }

                // 1. CurrentIndex is preserved
                if (restored.CurrentIndex != checkpoint.CurrentIndex)
                {
                    return false;
                }

                // 2. TotalCount is preserved
                if (restored.TotalCount != checkpoint.TotalCount)
                {
                    return false;
                }

                // 3. CompletedIndices are preserved
                if (restored.CompletedIndices.Count != checkpoint.CompletedIndices.Count)
                {
                    return false;
                }
                for (int i = 0; i < checkpoint.CompletedIndices.Count; i++)
                {
                    if (restored.CompletedIndices[i] != checkpoint.CompletedIndices[i])
                    {
                        return false;
                    }
                }

                // 4. FailedIndices are preserved
                if (restored.FailedIndices.Count != checkpoint.FailedIndices.Count)
                {
                    return false;
                }
                for (int i = 0; i < checkpoint.FailedIndices.Count; i++)
                {
                    if (restored.FailedIndices[i] != checkpoint.FailedIndices[i])
                    {
                        return false;
                    }
                }

                return true;
            });
    }

    /// <summary>
    /// Property 11 (Alternative): FlowStore Checkpoint Independence
    /// 
    /// *For any* flow with multiple checkpoints at different steps, each checkpoint 
    /// SHALL be independent and retrievable without affecting others.
    /// 
    /// **Validates: Requirements 5.17**
    /// 
    /// Feature: tdd-validation, Property 11: FlowStore Checkpoint Consistency (Independence)
    /// </summary>
    [Property(MaxTest = PropertyTestConfig.DefaultMaxTest)]
    public Property FlowStore_MultipleCheckpoints_AreIndependent()
    {
        return Prop.ForAll(
            Gen.Choose(1, 100000).ToArbitrary(),  // flowIdNum
            Gen.Choose(2, 5).ToArbitrary(),        // checkpointCount
            (flowIdNum, checkpointCount) =>
            {
                // Arrange
                var store = new InMemoryDslFlowStore();
                var flowId = $"flow-{flowIdNum}";
                var checkpoints = new Dictionary<int, ForEachProgress>();

                // Create multiple checkpoints at different steps
                for (int step = 0; step < checkpointCount; step++)
                {
                    var checkpoint = new ForEachProgress
                    {
                        CurrentIndex = step * 10,
                        TotalCount = 100,
                        CompletedIndices = Enumerable.Range(0, step * 5).ToList(),
                        FailedIndices = step > 0 ? new List<int> { step } : new List<int>()
                    };
                    checkpoints[step] = checkpoint;
                    store.SaveForEachProgressAsync(flowId, step, checkpoint).GetAwaiter().GetResult();
                }

                // Act & Assert - Verify each checkpoint is independent
                for (int step = 0; step < checkpointCount; step++)
                {
                    var restored = store.GetForEachProgressAsync(flowId, step).GetAwaiter().GetResult();
                    var expected = checkpoints[step];

                    if (restored == null)
                    {
                        return false;
                    }

                    if (restored.CurrentIndex != expected.CurrentIndex)
                    {
                        return false;
                    }

                    if (restored.TotalCount != expected.TotalCount)
                    {
                        return false;
                    }

                    if (restored.CompletedIndices.Count != expected.CompletedIndices.Count)
                    {
                        return false;
                    }

                    if (restored.FailedIndices.Count != expected.FailedIndices.Count)
                    {
                        return false;
                    }
                }

                return true;
            });
    }

    /// <summary>
    /// Property 11 (Clear): FlowStore Checkpoint Clear Removes Checkpoint
    /// 
    /// *For any* checkpoint that is saved and then cleared, retrieving it SHALL return null.
    /// 
    /// **Validates: Requirements 5.17**
    /// 
    /// Feature: tdd-validation, Property 11: FlowStore Checkpoint Consistency (Clear)
    /// </summary>
    [Property(MaxTest = PropertyTestConfig.DefaultMaxTest)]
    public Property FlowStore_ClearCheckpoint_RemovesCheckpoint()
    {
        return Prop.ForAll(
            Gen.Choose(1, 100000).ToArbitrary(),  // flowIdNum
            Gen.Choose(0, 10).ToArbitrary(),       // stepIndex
            (flowIdNum, stepIndex) =>
            {
                // Arrange
                var store = new InMemoryDslFlowStore();
                var flowId = $"flow-{flowIdNum}";
                
                var checkpoint = new ForEachProgress
                {
                    CurrentIndex = 5,
                    TotalCount = 10,
                    CompletedIndices = new List<int> { 0, 1, 2, 3, 4 },
                    FailedIndices = new List<int>()
                };

                // Act - Save then clear checkpoint
                store.SaveForEachProgressAsync(flowId, stepIndex, checkpoint).GetAwaiter().GetResult();
                store.ClearForEachProgressAsync(flowId, stepIndex).GetAwaiter().GetResult();
                
                // Act - Try to restore
                var restored = store.GetForEachProgressAsync(flowId, stepIndex).GetAwaiter().GetResult();

                // Assert - Should return null after clear
                return restored == null;
            });
    }
}

/// <summary>
/// Simple test flow state for property testing - avoids complex types that cause serialization issues
/// </summary>
public class SimpleTestFlowState : IFlowState
{
    public string? FlowId { get; set; }
    public string OrderId { get; set; } = string.Empty;
    public int Amount { get; set; }
    public string Status { get; set; } = "Pending";

    public bool HasChanges => true;
    public int GetChangedMask() => 0;
    public bool IsFieldChanged(int fieldIndex) => false;
    public void ClearChanges() { }
    public void MarkChanged(int fieldIndex) { }
    public IEnumerable<string> GetChangedFieldNames() { yield break; }
}

/// <summary>
/// Simple test flow state with items collection for property testing
/// </summary>
public class SimpleTestFlowStateWithItems : IFlowState
{
    public string? FlowId { get; set; }
    public string OrderId { get; set; } = string.Empty;
    public int Amount { get; set; }
    public string Status { get; set; } = "Pending";
    public List<string> Items { get; set; } = new();

    public bool HasChanges => true;
    public int GetChangedMask() => 0;
    public bool IsFieldChanged(int fieldIndex) => false;
    public void ClearChanges() { }
    public void MarkChanged(int fieldIndex) { }
    public IEnumerable<string> GetChangedFieldNames() { yield break; }
}
